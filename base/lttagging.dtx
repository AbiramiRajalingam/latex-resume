% \iffalse meta-comment
%
% Copyright (C) 2023
% The LaTeX Project and any individual authors listed elsewhere
% in this file.
%
% This file is part of the LaTeX base system.
% -------------------------------------------
%
% It may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3c
% of this license or (at your option) any later version.
% The latest version of this license is in
%    https://www.latex-project.org/lppl.txt
% and version 1.3c or later is part of all distributions of LaTeX
% version 2008 or later.
%
% This file has the LPPL maintenance status "maintained".
%
% The list of all files belonging to the LaTeX base distribution is
% given in the file `manifest.txt'. See also `legal.txt' for additional
% information.
%
% The list of derived (unpacked) files belonging to the distribution
% and covered by LPPL is defined by the unpacking scripts (with
% extension .ins) which are part of the distribution.
%
% \fi
%
% \iffalse
%%% From File: lttagging.dtx
%
%<*driver>
% \fi
\ProvidesFile{lttagging.dtx}
             [2023/12/01 v1.0a LaTeX Kernel (tagging support)]
% \iffalse
\documentclass{ltxdoc}
\GetFileInfo{lttagging.dtx}
\title{\filename}
\date{\filedate}
\author{\LaTeX{} project}

\begin{document}
 \MaintainedByLaTeXTeam{latex}
 \maketitle
 \DocInput{\filename}
\end{document}
%</driver>
% \fi
%
% \providecommand\env[1]{\texttt{#1}}
%
% \providecommand\hook[1]{\texttt{#1\DescribeHook[noprint]{#1}}}
% \providecommand\socket[1]{\texttt{#1\DescribeSocket[noprint]{#1}}}
% \providecommand\plug[1]{\texttt{#1\DescribePlug[noprint]{#1}}}
%
% \ProvideDocElement[printtype=\textit{socket},idxtype=socket,idxgroup=Sockets]{Socket}{socketdecl}
% \ProvideDocElement[printtype=\textit{hook},idxtype=hook,idxgroup=Hooks]{Hook}{hookdecl}
% \ProvideDocElement[printtype=\textit{plug},idxtype=plug,idxgroup=Plugs]{Plug}{plugdecl}
%
%
% \section{}
%
%
%
% \MaybeStop{}
%
%    \begin{macrocode}
%<*2ekernel|latexrelease>
%    \end{macrocode}
%
% \subsection{General support for tagged output}
%
%  \begin{macro}{\SuspendTagging,\ResumeTagging}
%    
%    This should move to tagpdf and to kernel so that one definition
%    is automatically available!
%    \begin{macrocode}
\ExplSyntaxOn

\cs_set_eq:NN \SuspendTagging \use_none:n  
\cs_set_eq:NN \ResumeTagging  \use_none:n

\AddToHook{begindocument/before}{
  \cs_if_exist:NT \tag_stop:n
  { 
    \cs_set:Npn \SuspendTagging #1 {
      \tag_stop:n {#1} 
%    \end{macrocode}%
%    Next line is is incomplete (only disables table sockets) and
%    should instead be done in the above command instead of disabling them
%    individually because that will otherwise forever change if new
%    sockets get used.
%    \begin{macrocode}
      \__tag_tbl_disable:
    }
%    \end{macrocode}
%
%    \begin{macrocode}
    \cs_set:Npn \ResumeTagging #1 {
      \tag_start:n {#1}
      \__tag_tbl_enable:
    }
  }
}
\ExplSyntaxOff  
%    \end{macrocode}
%  \end{macro}
%
%
% \subsection{Tagging support for table/tabular packages}
%
% The code uses a number of sockets to inject the tagging
% commands. These can be easily set to a noop-plug in case the
% automated tagging is not wanted.  At first sockets for the begin and
% end of cells and rows
%
% \begin{socketdecl}{tagsupport/tblcell/begin,
%                    tagsupport/tblcell/end,
%                    tagsupport/tblpcell/end,
%                    tagsupport/tblpcell/end,
%                    tagsupport/tblrow/begin,
%                    tagsupport/tblrow/end,
%                   }
%    \begin{macrocode}
\NewSocket{tagsupport/tblcell/begin}{0}
\NewSocket{tagsupport/tblcell/end}{0}

\NewSocket{tagsupport/tblpcell/begin}{0}
\NewSocket{tagsupport/tblpcell/end}{0}

\NewSocket{tagsupport/tblrow/begin}{0}
\NewSocket{tagsupport/tblrow/end}{0}
%    \end{macrocode}
% \end{socketdecl}
%
% \begin{socketdecl}{tagsupport/tbl/init}
%    This socket should be at the begin of the table, inside a group.
%    It is meant for settings like disabling paratagging.  This socket
%    can perhaps be merged later into the begin-sockets when they are
%    no longer added as hooks but in the environment definitions.
%    \begin{macrocode}
\NewSocket{tagsupport/tbl/init}{0}
%    \end{macrocode}
% \end{socketdecl}
%
%
% \begin{socketdecl}{tagsupport/tbl/finalize}
%    To fine tune the structure (change cells to header cells, remove
%    unwanted structures, move a foot to the end, etc.) we also need a
%    socket that is executed at the end of the table but \emph{before}
%    all the variables are restored to the outer or default values.
%    The code in the socket can make assignments, but probably
%    shouldn't do typesetting and not write whatsits.
%    \begin{macrocode}
\NewSocket{tagsupport/tbl/finalize}{0}
%    \end{macrocode}
% \end{socketdecl}
%


% \begin{socketdecl}{tagsupport/tbl/colspan}
%    This socket
%    \begin{macrocode}
\NewSocket{tagsupport/tbl/colspan}{1}
%    \end{macrocode}
% \end{socketdecl}
%


% \begin{socketdecl}{tagsupport/tbl/finalize/longtable}
%    \env{longtable} needs its own socket to fine tune the structure.
%    Simply switching the plug in the previous socket interferes with
%    enabling/disabling the tagging.
%    \begin{macrocode}
\NewSocket{tagsupport/tbl/finalize/longtable}{0}
%    \end{macrocode}
% \end{socketdecl}
%
% \begin{socketdecl}{tagsupport/tblhmode/begin,
%                    tagsupport/tblhmode/end,
%                    tagsupport/tblvmode/begin,
%                    tagsupport/tblvmode/end
%                   }
%
%    These sockets are used in the begin and end code of environments,
%    to allow a fast enabling and disabling of the tagging. We
%    distinguish between tables that can be used inside paragraphs and
%    standalone tables like longtable.
%    \begin{macrocode}
\NewSocket{tagsupport/tblhmode/begin}{0}
\NewSocket{tagsupport/tblhmode/end}{0}
\NewSocket{tagsupport/tblvmode/begin}{0}
\NewSocket{tagsupport/tblvmode/end}{0}
%    \end{macrocode}
% \end{socketdecl}
%
%
% \begin{socketdecl}{tbl/celldata/multicolumn}
%    Temporary sockets that will most likely vanish again.
%    \begin{macrocode}
\NewSocket{tbl/celldata/multicolumn}{1}
\AssignSocketPlug{tbl/celldata/multicolumn}{noop}
%    \end{macrocode}
% \end{socketdecl}
%
%
%  \begin{macro}{\tag_socket_use:n,
%                \tag_socket_use:nn,
%                \UseTaggingSocket,
%               }
%    
%    \begin{macrocode}
\ExplSyntaxOn

\AddToHook{begindocument}[kernel]{
  \cs_if_exist:NF \tag_if_active:T
     {
       \prg_new_conditional:Npnn \tag_if_active: { p , T , TF, F }
           { \prg_return_false: }
     }
}

\cs_new_protected:Npn \tag_socket_use:n #1 {
  \tag_if_active:T
      { \UseSocket {tagsupport/#1} }
}
\cs_new_protected:Npn \tag_socket_use:nn #1#2 {
  \tag_if_active:T
      { \UseSocket {tagsupport/#1} {#2} }
}

\cs_new_protected:Npn \UseTaggingSocket #1 {
  \tag_if_active:TF
      { \UseSocket{tagsupport/#1} }
      {
        \int_case:nnF
            { \int_use:c { c__socket_tagsupport/#1_args_int } }
            {
              0 \prg_do_nothing:
              1 \use_none:n
              2 \use_none:nn
            }
            \ERRORusetaggingsocket
      }
}
\ExplSyntaxOff
%    \end{macrocode}
%  \end{macro}
%
%
%
% \section{For lttab.dtx parked here for now}
%
%    
%    \begin{macrocode}
%<@@=tbl>
\ExplSyntaxOn
%    \end{macrocode}
%
%
% \subsection{Variables for row, column and span counting}
%
%
%
%  \begin{macro}{
%     \g_@@_col_int,
%     \g_@@_row_int,
%     \g_@@_span_tl,
%     \g_@@_table_cols_tl}
%    \cs{g_@@_row_int} holds the current row number in the table. The value
%    \texttt{0} means we haven't yet processed the table preamble. It
%    is incremented by every \cs{cr} including the one ending the
%    table preamble.
%
%    \cs{g_@@_col_int} holds the current column number. The value
%    \texttt{0} means we have not yet started the table or just finished a table row
%    (with \verb=\\= typically); any other positive value means we
%    are currently typesetting a cell in that column in some row
%    (denoted by the \cs{g_@@_row_int}.
%
%    In a \cs{multicolumn} it holds the column number of the first
%    spanned column and \cs{g_@@_span_tl} the info how many cells are
%    spanned.
%
%    \cs{g_@@_span_tl} is normally \texttt{1} except in a
%    \cs{multicolumn} cell.
%    \begin{macrocode}
\int_new:N \g_@@_col_int
\int_new:N \g_@@_row_int
\tl_new:N  \g_@@_span_tl
\tl_new:N  \g_@@_table_cols_tl

\tl_gset:Nn \g_@@_span_tl {1}
\tl_gset:Nn \g_@@_table_cols_tl {0}  % indicates outer level
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\l_@@_saved_col_tl,\l_@@_saved_row_tl,
%                \l_@@_saved_span_tl,\l_@@_saved_table_cols_tl}
%
%    Saving the outer values if we are nesting tables is necessary (as
%    the above variables are globally altered. For this we use always
%    token lists because they don't change and we do not need to blow
%    additional integer registers.
%    \begin{macrocode}
\tl_new:N \l_@@_saved_col_tl
\tl_new:N \l_@@_saved_row_tl
\tl_new:N \l_@@_saved_span_tl
\tl_new:N \l_@@_saved_table_cols_tl

\tl_set:Nn \l_@@_saved_col_tl{0}
\tl_set:Nn \l_@@_saved_row_tl{0}
\tl_set:Nn \l_@@_saved_span_tl{1}
\tl_set:Nn \l_@@_saved_table_cols_tl{0}  % indicates outer level
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\g_@@_missingcells_int}
% This will contain the number of missing cells in a row:
%    \begin{macrocode}
\int_new:N \g_@@_missing_cells_int
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
% \subsection{Tracing/debugging}
%
%  \begin{macro}{\DebugTablesOn,\DebugTablesOff}
%    
%    \begin{macrocode}
\def\DebugTablesOn{
  \cs_set_eq:NN \@@_trace:n \typeout
}  
\def\DebugTablesOff{
  \cs_set_eq:NN \@@_trace:n \use_none:n
}  
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_eq:NN \@@_trace:n \use_none:n
%    \end{macrocode}
%  \end{macro}
%
%
%
% \subsection{Interface commands}
%
%  \begin{macro}{\tbl_update_cell_data:}
%    Updating cell data in columns after the first means we have to
%    increment the \cs{g_@@_col_int} by the span count of the previous
%    cell (in case it was a \cs{multicolumn} and then reset the
%    \cs{g_@@_span_tl} to one (as the default).
%    \begin{macrocode}
\cs_new_protected:Npn \tbl_update_cell_data: {
        \int_gadd:Nn \g_@@_col_int { \g_@@_span_tl }
        \tl_gset:Nn  \g_@@_span_tl {1}
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{\tbl_count_missing_cells:n}
%    We might have the situation that some table package has not
%    implemented the \cs{} in which case \cs{g_@@_table_cols_tl} would
%    always be zero and we would get an error below when we try to
%    determine the missing cells, so bypass that calculation if we
%    aren't doing tagging (there the packages should have the proper
%    code added).
%    \begin{macrocode}
\cs_new:Npn \tbl_count_missing_cells:n #1 {
  \tag_if_active:T {
    \int_compare:nNnT \g_@@_col_int > 0
      {
        \int_gset:Nn \g_@@_missing_cells_int
            {
              \g_@@_table_cols_tl
            - \g_@@_col_int
            - \g_@@_span_tl
            + 1
            }
        \int_compare:nNnT \g_@@_missing_cells_int < 0 \ERRORmissingcells % should not happen
        \@@_trace:n{==>~
          (#1)~
          This~ row~ needs~
          \int_use:N \g_@@_missing_cells_int \space
          additional~ cell(s)
        }
      }
  }
}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\tbl_count_table_cols:}
%    Current implementation of \cs{@mkpream} uses the scratch counter
%    \cs{count@} to keep track of the number of toks registers it needs
%    (2 per column), but this can't be used as it counts also
%    insertings made with \verb+!{}+ and \verb+@{}+.
%    So similar as does longtable for \cs{LT@cols} we count the
%    numbers of ambersands instead.
%    \begin{macrocode}
\cs_new:Npn \tbl_count_table_cols:  {
  \seq_set_split:NnV\l_@@_tmpa_seq {&}\@preamble
  \tl_gset:Ne \g_@@_table_cols_tl { \seq_count:N \l_@@_tmpa_seq }
  \@@_trace:n { ==>~ Table~ has~ \g_@@_table_cols_tl \space columns }
}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\tbl_init_cell_data_for_table:}
%    
%    \begin{macrocode}
\cs_new_protected:Npn \tbl_init_cell_data_for_table: {
  \tl_set:No \l_@@_saved_col_tl {\int_use:N \g_@@_col_int }
  \tl_set:No \l_@@_saved_row_tl {\int_use:N \g_@@_row_int }
  \tl_set_eq:NN \l_@@_saved_span_tl  \g_@@_span_tl
%
  \@@_trace:n { ==>~ saved~cell~data:~
                \l_@@_saved_row_tl,
                \l_@@_saved_col_tl,
                \l_@@_saved_span_tl \space
                (
                \int_compare:nNnTF \l_@@_saved_table_cols_tl = 0
                    { outer~ level }
                    { max:~ \l_@@_saved_table_cols_tl }
                )
          }
%    \end{macrocode}
%    These are the initial values when starting a table:
%    \begin{macrocode}
  \int_gzero:N \g_@@_row_int
  \int_gzero:N \g_@@_col_int
  \tl_gset:Nn  \g_@@_span_tl {1}
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\tbl_init_cell_data_for_row:}
%    \begin{macrocode}
\cs_new_protected:Npn \tbl_init_cell_data_for_row: {
        \int_gset:Nn \g_@@_col_int {1}
        \tl_gset:Nn  \g_@@_span_tl {1}
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
%  \begin{macro}{\tbl_restore_outer_cell_data:}
%    
%    \begin{macrocode}
\cs_new_protected:Npn \tbl_restore_outer_cell_data: {
  \int_gset:Nn \g_@@_col_int { \l_@@_saved_col_tl }
  \int_gset:Nn \g_@@_row_int { \l_@@_saved_row_tl }
  \tl_gset_eq:NN \g_@@_span_tl \l_@@_saved_span_tl
  \tl_gset_eq:NN \g_@@_table_cols_tl   \l_@@_saved_table_cols_tl
  \@@_trace:n { ==>~ restored~cell~data:~
                \int_use:N \g_@@_row_int,
                \int_use:N \g_@@_col_int,
                \l_@@_saved_span_tl \space
                (
                \int_compare:nNnTF \g_@@_table_cols_tl = 0
                    { outer~ level }
                    { max:~ \g_@@_table_cols_tl }
                )
              }
}
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%
%
%    \begin{macrocode}
\ExplSyntaxOff
%<@@=>
%    \end{macrocode}
%
%
%
% Should there be a module?
%
%    \begin{macrocode}
%<latexrelease>\NewModuleRelease{2024/06/01}{lttagging}
%<latexrelease>                 {Tagging support}
%    \end{macrocode}
%
%
%
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{0000/00/00}{lttagging}%
%<latexrelease>                 {Undo tagging support}
%<latexrelease>
%<latexrelease>
%<latexrelease>
%<latexrelease>\EndModuleRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%</2ekernel|latexrelease>
%    \end{macrocode}
%
% \Finale
%
