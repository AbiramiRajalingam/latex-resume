% \iffalse meta-comment
%
%% File: ltfilehook.dtx (C) Copyright 2020 Frank Mittelbach, LaTeX Team
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    https://www.latex-project.org/lppl.txt
%
%
% The development version of the bundle can be found below
%
%    https://github.com/FrankMittelbach/...
%
% for those people who are interested or want to report an issue.
%
%    \begin{macrocode}
\providecommand\ltfilehookversion{v0.9b}
\providecommand\ltfilehookdate{2020/08/17}
%    \end{macrocode}
%
%<*driver>

\RequirePackage{lthooks}        % needed for structedlog if running old format

\documentclass{l3doc}

% bug fix fo l3doc.cls
\ExplSyntaxOn
\cs_set_protected:Npn \__codedoc_macro_typeset_one:nN #1#2
  {
    \vbox_set:Nn \l__codedoc_macro_box
      {
        \vbox_unpack_drop:N \l__codedoc_macro_box
        \hbox { \llap { \__codedoc_print_macroname:nN {#1} #2
            \MacroFont       % <----- without it the \ is in lmr10 if a link is made
            \      
        } }
      }
    \int_incr:N \l__codedoc_macro_int
  }
\ExplSyntaxOff

\usepackage{structuredlog}  % for demonstration

\EnableCrossrefs
\CodelineIndex
\begin{document}
  \DocInput{ltfilehook.dtx}
\end{document}
%</driver>
%
% \fi
%
%
% \long\def\fmi#1{\begin{quote}\itshape Todo: #1\end{quote}}
%
% \let\hook\texttt
%
% \title{The \texttt{ltfilehook} package\thanks{This package has version
%    \ltfilehookversion\ dated \ltfilehookdate, \copyright\ \LaTeX\
%    Project.}}
%
% \author{Frank Mittelbach}
%
% \maketitle
%
%
%
% \tableofcontents
%
% \section{Introduction}
%
%
%
% \subsection{Provided hooks}
%
%    The code offers a number of hooks into which packages (or the
%    user) can add code to support different use cases.
%    Many hooks are offered as pairs (i.e., the second hook is
%    reversed. Also important to know is that these pairs are
%    properly nested with respect to other pairs of hooks.
%
%    There are hooks that are executed for all files of a certain type
%    (if they contain code), e.g., for all \enquote{include files} or
%    all \enquote{packages},
%    and there are also hooks that are specific to a single file,
%    e.g., do something after the package \texttt{foo.sty} has been
%    loaded.
%
%
% \subsection{General hooks for file reading}
% \label{sec:general-file-hooks}
%
%    There are four hooks that are called for each file that is read
%    using document-level commands such as \cs{input}, \cs{include},
%    \cs{usepackage}, etc.  They are not called for files read using
%    internal low-level methods, such as \cs{@input} or \cs{openin}.
%
%  \begin{variable}{file/before,file/before/...,
%                   file/after/...,file/after,
%                   }
%    These are:
%    \begin{description}
%    \item[\texttt{file/before}, \texttt{file/before/\meta{file-name}}]
%
%       These hooks are executed in that order just before the file is
%       loaded for reading. The code of the first hook is used is used
%       with every file, while the second is executed only for the
%       file with matching \meta{file-name} allowing you to specify
%       code that only applies to one file.
%
%    \item[\texttt{file/after/\meta{file-name}}, \texttt{file/after}]
%
%       These hooks are after the file with name \meta{file-name} has
%       been fully consumed. The order is swapped (the specific one
%       comes first) so that the \texttt{before} and \texttt{after}
%       hooks nest properly, which is important if any of them involve
%       grouping (e.g., contain environments, for example).
%       furthermore both hooks are reversed hooks to support correct
%       nesting of different packages add code to both
%       \texttt{/before} and \texttt{/after} hooks.
%
%    \end{description}
%  \end{variable}
%
%
%     So the overall sequence of hook processing for any file read
%     through the user interface commands of \LaTeX{} is:
%
%  \begin{tabbing}
%    mm\=mm\=mm\=mm\=\kill
%    \>\cs{UseHook}\marg{\hook{file/before}} \\
%    \>\cs{UseHook}\marg{\hook{file/before/\meta{file name}}} \\
%    \>\> \meta{file contents} \\
%    \>\cs{UseHook}\marg{\hook{file/after/\meta{file name}}} \\
%    \>\cs{UseHook}\marg{\hook{file/after}}
%  \end{tabbing}
%
%     \fmi{With a higher-level interface that doesn't matter, but it
%    is a bit weird, if you use \cs{AddToHook} or \cs{hook_gput:nnn}
%    directly, so I guess that has to be done differently!}
%
%    The file hooks only refer to the file by its name and extension,
%    so the \meta{file name} should be the file name as it is on the
%    filesystem with extension (if any) and without paths.  Different
%    from \cs{input} and similar commands, for hooks the \texttt{.tex}
%    extension is not assumed, so \texttt{.tex} files must also be given
%    with their extension.
%    Files within subfolders should also be addressed by their name and
%    extension only.
%
%    Extensionless files also work, and should then be given without
%    extension.  Note however that \TeX{} prioritizes \texttt{.tex}
%    files, so if two files \texttt{foo} and \texttt{foo.tex} exist in
%    the search path, only the latter will be seen.
%
%    When a file is input, the \meta{file name} is available in
%    \cs{CurrentFile}, which is then used when accessing the
%    \hook{file/before/\meta{file name}} and
%    \hook{file/after/\meta{file name}}.
%
%  \begin{variable}{\CurrentFile}
%    The name of the file about to be read (or just finished) is
%    available to the hooks through \cs{CurrentFile} (there is no
%    \texttt{expl3} name for it for now).  The file is always provided
%    with its extension, i.e., how it appears on your hard drive, but
%    without any specified path to it. For example,
%    \verb=\input{sample}= and \verb=\input{app/sample.tex}= would
%    both have \cs{CurrentFile} being \texttt{sample.tex}.
%  \end{variable}
%
%  \begin{variable}{\CurrentFilePath}
%    The path to the current file (complement to \cs{CurrentFile}) is
%    available in \cs{CurrentFilePath} if needed.
%    The paths returned in \cs{CurrentFilePath} are only user paths,
%    given through \cs{input@path} (or \pkg{expl3}'s equivalent
%    \cs{l_file_search_path_seq}) or by directly typing in the path
%    in the \cs{input} command or equivalent.  Files located by
%    \texttt{kpsewhich} get the path added internally by the \TeX{}
%    implementation, so at the macro level it looks as if the file were
%    in the current folder, so the path in \cs{CurrentFilePath} is empty
%    in these cases (package and class files, mostly).
%  \end{variable}
%
%  \begin{variable}{\CurrentFileUsed,\CurrentFilePathUsed}
%    In normal circumstances these are identical to \cs{CurrentFile} and
%    \cs{CurrentFilePath}.  They will differ when a file substitution
%    has occurred for \cs{CurrentFile}.  In that case,
%    \cs{CurrentFileUsed} and \cs{CurrentFilePathUsed} will hold the
%    actual file name and path loaded by \LaTeX, while \cs{CurrentFile}
%    and \cs{CurrentFilePath} will hold the names that were
%    \emph{asked for}.  Unless doing very specific work on the file
%    being read, \cs{CurrentFile} and \cs{CurrentFilePath} should be
%    enough.
%  \end{variable}
%
% \subsection{Hooks for package and class files}
%
%    Commands to load package and class files (e.g., \cs{usepackage},
%    \cs{RequirePackage}, \cs{LoadPackageWithOptions}, etc.) offer the
%    hooks from section~\ref{sec:general-file-hooks} when they are
%    used to load a  package or class file, e.g.,
%    \texttt{file/after/array.sty} would be called after the
%    \pkg{array} package got loaded. But as packages and classes form as special group
%    of files, there are some additional hooks available that only
%    apply when a package or class is loaded.
%
%
%  \begin{variable}{
%                   package/before,package/after,
%                   package/before/...,package/after/...,
%                   class/before,class/after,
%                   class/before/...,class/after/...,
%                   }
%    These are:
%    \begin{description}
%    \item[\texttt{package/before}, \texttt{package/after}]
%
%      These hooks are called for each package being loaded.
%
%    \item[\texttt{package/before/\meta{name}},
%    \texttt{package/after/\meta{name}}]
%
%      These hooks are additionally called if the package name is
%      \meta{name} (without extension).
%
%    \item[\texttt{class/before}, \texttt{class/after}]
%
%      These hooks are called for each class being loaded.
%
%    \item[\texttt{class/before/\meta{name}}, \texttt{class/after/\meta{name}}]
%
%      These hooks are additionally called if the class name is
%      \meta{name} (without extension).
%
%    \end{description}
%  \end{variable}
%     All \hook{/after} hooks are implemented as reversed hooks.
%
%     \noindent The overall sequence of execution for \cs{usepackage}
%     and friends is therefore:
%  \begin{tabbing}
%    mm\=mm\=mm\=mm\=\kill
%    \>\cs{UseHook}\marg{\hook{package/before}} \\
%    \>\cs{UseHook}\marg{\hook{package/before/\meta{package name}}} \\[5pt]
%    \>\>\cs{UseHook}\marg{\hook{file/before}} \\
%    \>\>\cs{UseHook}\marg{\hook{file/before/\meta{package name}.sty}} \\
%    \>\>\> \meta{package contents} \\
%    \>\>\cs{UseHook}\marg{\hook{file/after/\meta{package name}.sty}} \\
%    \>\>\cs{UseHook}\marg{\hook{file/after}} \\[5pt]
%    \>\>\emph{code from \cs{AtEndOfPackage} if
%                used inside the package} \\[5pt]
%    \>\cs{UseHook}\marg{\hook{package/after/\meta{package name}}} \\
%    \>\cs{UseHook}\marg{\hook{package/after}} 
%  \end{tabbing}
%    and similar for class file loading, except that \texttt{package/}
%    is replaced by \texttt{class/} and \cs{AtEndOfPackage} by
%    \cs{AtEndOfClass}.
%
%    If a package or class is not loaded (or it was loaded before the
%    hooks were set) none of the hooks are executed!
%
% \subsection{Hooks for \cs{include} files}
%
%    To manage \cs{include} files, \LaTeX{} issues a \cs{clearpage}
%    before and after loading such a file. Depending on the use case
%    one may want to execute code before or after these
%    \cs{clearpage}s especially for the one that is issued at the end.
%
%    Executing code before the final \cs{clearpage}, means that the
%    code is processed while the last page of the included material is
%    still under construction.  Executing code after it means that all
%    floats from inside the include file are placed (which
%    might have added further pages) and the final page has finished.
%
%    Because of these different scenarios we offer hooks in three
%    places.\footnote{If you want to execute code before the first
%     \cs{clearpage} there is no need to use a hook---you can write it
%     directly in front of the \cs{include}.}
%    None of the hooks are executed when an \cs{include} file is
%    bypassed because of an \cs{includeonly} declaration. They are,
%    however, all executed if \LaTeX{} makes an attempt to load the
%    \cs{include} file (even if it doesn't exist and all that happens
%    is \enquote{\texttt{No file \meta{filename}.tex}}).
%
%
%  \begin{variable}{include/before,include/before/...,
%                   include/end,include/end/...,
%                   include/after,include/after/...,
%                  }
%    These are:
%    \begin{description}
%
%    \item[\texttt{include/before}, \texttt{include/before/\meta{name}}]
%
%      These hooks are executed one after another after the initial
%      \cs{clearpage} and after \texttt{.aux} file is changed to use
%      \texttt{\meta{name}.aux}, but before the
%      \texttt{\meta{name}.tex} file is loaded. In other words they are executed
%      at the very beginning of the first page of the \cs{include}
%      file.
%
%
%    \item[\texttt{include/end/\meta{name}}, \texttt{include/end}]
%
%      These hooks are executed (in that order) after \LaTeX{} has
%      stopped reading from the \cs{include} file, but before it has
%      issued a \cs{clearpage} to output any deferred floats.
%
%
%    \item[\texttt{include/after/\meta{name}}, \texttt{include/after}]
%
%      These hooks are executed (in that order) after \LaTeX{} has
%      issued the \cs{clearpage} but before is has switched back
%      writing to the main \texttt{.aux} file. Thus technically we are
%      still inside the \cs{include} and if the hooks generate any
%      further typeset material including anything that writes to the
%      \texttt{.aux} file, then it would be considered part of the
%      included material and bypassed if it is not loaded because of
%      some \cs{includeonly} statement.\footnotemark
%
%    \end{description}
%  \end{variable}\footnotetext{For that reason
%      another \cs{clearpage} is executed after these hooks which
%      normally does nothing, but starts a new page if further material
%      got added this way.}
%
% \subsection{High-level interfaces for \LaTeX{}}
%
%    We do not provide any high-level \LaTeX{} commands (like
%    \pkg{filehook} or \pkg{scrlfile} do) but think that for package
%    writers the commands from for hook management are sufficient.
%
% \subsection{A sample package for structuring the log output}
%
%    As an application we provide the package \pkg{structuredlog} that
%    adds lines to the \texttt{.log} when a file is opened and closed
%    for reading keeping track of nesting level es well.
%    For example, for the current document it adds the lines
%\begin{verbatim}
%    = (LEVEL 1 START) t1lmr.fd
%    = (LEVEL 1 STOP) t1lmr.fd
%    = (LEVEL 1 START) supp-pdf.mkii
%    = (LEVEL 1 STOP) supp-pdf.mkii
%    = (LEVEL 1 START) nameref.sty
%    == (LEVEL 2 START) refcount.sty
%    == (LEVEL 2 STOP) refcount.sty
%    == (LEVEL 2 START) gettitlestring.sty
%    == (LEVEL 2 STOP) gettitlestring.sty
%    = (LEVEL 1 STOP) nameref.sty
%    = (LEVEL 1 START) ltfilehook-doc.out
%    = (LEVEL 1 STOP) ltfilehook-doc.out
%    = (LEVEL 1 START) ltfilehook-doc.out
%    = (LEVEL 1 STOP) ltfilehook-doc.out
%    = (LEVEL 1 START) ltfilehook-doc.hd
%    = (LEVEL 1 STOP) ltfilehook-doc.hd
%    = (LEVEL 1 START) ltfilehook.dtx
%    == (LEVEL 2 START) ot1lmr.fd
%    == (LEVEL 2 STOP) ot1lmr.fd
%    == (LEVEL 2 START) omllmm.fd
%    == (LEVEL 2 STOP) omllmm.fd
%    == (LEVEL 2 START) omslmsy.fd
%    == (LEVEL 2 STOP) omslmsy.fd
%    == (LEVEL 2 START) omxlmex.fd
%    == (LEVEL 2 STOP) omxlmex.fd
%    == (LEVEL 2 START) umsa.fd
%    == (LEVEL 2 STOP) umsa.fd
%    == (LEVEL 2 START) umsb.fd
%    == (LEVEL 2 STOP) umsb.fd
%    == (LEVEL 2 START) ts1lmr.fd
%    == (LEVEL 2 STOP) ts1lmr.fd
%    == (LEVEL 2 START) t1lmss.fd
%    == (LEVEL 2 STOP) t1lmss.fd
%    = (LEVEL 1 STOP) ltfilehook.dtx
%\end{verbatim}
%    Thus if you inspect an issue in the \texttt{.log} it is easy to
%    figure out in which file it occurred, simply by searching back for
%    \texttt{LEVEL} and if it is a \texttt{STOP} then remove 1 from
%    the level value and search further for \texttt{LEVEL} with that value
%    which should then be the \texttt{START}  level of the file you are in.
%
% \StopEventually{\setlength\IndexMin{200pt}  \PrintIndex  }
%
%
% \section{The Implementation}
%    \begin{macrocode}
%<*2ekernel>
%    \end{macrocode}
%
% \subsection{\pkg{expl3} helpers}
%
%    \begin{macrocode}
%<@@=filehook>
\ExplSyntaxOn
%    \end{macrocode}
%
% \begin{macro}{\CurrentFile,\CurrentFilePath}
% \begin{macro}{\CurrentFileUsed,\CurrentFilePathUsed}
%   User-level macros that hold the current file name and file path.
%   These are used internally as well because the code takes care to
%   protect against a possible redefinition of these macros in the
%   loaded file (it's necessary anyway to make hooks work with nested
%   \cs{input}).  The versions |\...Used| hold the \emph{actual} file
%   name and path that is loaded by \LaTeX, whereas the other two hold
%   the name as requested.  They will differ in case there's a file
%   substitution.
%    \begin{macrocode}
\tl_new:N \CurrentFile
\tl_new:N \CurrentFilePath
\tl_new:N \CurrentFileUsed
\tl_new:N \CurrentFilePathUsed
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{
%     \@@_file_parse_full_name:nN,
%     \@@_full_name:nn,
%     \@@_set_curr_file_assign:nnnNN
%   }
%   A utility macro to trigger \pkg{expl3}'s file-parsing and lookup,
%   and return a normalised representation of the file name.  If the
%   queried file doesn't exist, no normalisation takes place.
%   The output of \cs{@@_file_parse_full_name:nN} is passed on to the
%   |#2|---a 3-argument macro that takes the \meta{path}, \meta{base},
%   and \meta{ext} parts of the file name.
%    \begin{macrocode}
\cs_new:Npn \@@_file_parse_full_name:nN #1
  {
    \exp_args:Nf \file_parse_full_name_apply:nN
      {
        \exp_args:Nf \@@_full_name:nn
          { \file_full_name:n {#1} } {#1}
      }
  }
\cs_new:Npn \@@_full_name:nn #1 #2
  {
    \tl_if_empty:nTF {#1}
      { \tl_trim_spaces:n {#2} }
      { \tl_trim_spaces:n {#1} }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_@@_input_file_seq,\l_@@_internal_tl}
% \begin{macro}{\@filehook@file@push,\@filehook@file@pop}
% \begin{macro}{\@@_file_pop_assign:nnnn}
%   Yet another stack, to keep track of \cs{CurrentFile} and
%   \cs{CurrentFilePath} with nested \cs{input}s.  At the beginning of
%   \cs{InputIfFileExists}, the current value of \cs{CurrentFilePath}
%   and \cs{CurrentFile} is pushed to \cs{g_@@_input_file_seq}, and
%   at the end, it is popped and the value reassigned.  Some other
%   places don't use \cs{InputIfFileExists} directly (\cs{include}) or
%   need \cs{CurrentFile} earlier (\cs{@onefilewithoptions}), so these
%   are manually used elsewhere as well.
%    \begin{macrocode}
\tl_new:N \l_@@_internal_tl
\seq_new:N \g_@@_input_file_seq
\cs_new_protected:Npn \@filehook@file@push
  {
    \seq_gpush:Nx \g_@@_input_file_seq
      {
        { \CurrentFilePathUsed } { \CurrentFileUsed }
        { \CurrentFilePath     } { \CurrentFile     }
      }
  }
\cs_new_protected:Npn \@filehook@file@pop
  {
    \seq_gpop:NNTF \g_@@_input_file_seq \l_@@_internal_tl
      { \exp_after:wN \@filehook@file@pop@assign \l_@@_internal_tl }
      {
        \msg_error:nnn { hooks } { should-not-happen }
          { Tried~to~pop~from~an~empty~file~name~stack. }
      }
  }
\cs_new_protected:Npn \@filehook@file@pop@assign #1 #2 #3 #4
  {
    \tl_set:Nn \CurrentFilePathUsed {#1}
    \tl_set:Nn \CurrentFileUsed {#2}
    \tl_set:Nn \CurrentFilePath {#3}
    \tl_set:Nn \CurrentFile {#4}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
%    \begin{macrocode}
\ExplSyntaxOff
%<@@=>
%    \end{macrocode}
%
% \subsection{Declaring the file-related hooks}
%
%  All hooks starting with \texttt{file/} \texttt{include/},
%  \texttt{class/} or \texttt{package/} are generic and will be
%  allocated if code is added to them. Thus there is no need to
%  explicitly declare any hook in the code below.
%
%  Furthermore, those named \texttt{.../after} or \texttt{.../end} are
%  automatically declared as reversed hooks if filled with code, so this
%  is also automatically taken care of.
%
% \subsection{Patching \LaTeX{} commands (need proper integration later)}
%
%    Most of what we have to do is adding \cs{UseHook} into several
%  \LaTeXe{} core commands, which is done for now by patching them.
%
% \begin{macro}{\InputIfFileExists}
%    \cs{InputIfFileExists} loads any file if it is available so we
%    have to add the hooks \texttt{file/before} and
%    \texttt{file/after} in the right places. If the file doesn't
%    exist no hooks should be executed.
%    \begin{macrocode}
\let\InputIfFileExists\@undefined
\DeclareRobustCommand \InputIfFileExists[2]{%
  \IfFileExists{#1}%
    {%
     \@filehook@file@push
     \@filehook@set@CurrentFile
%    \end{macrocode}
%    If the file exists then \cs{@curr@file} holds its name. But we
%    can't rely on that still being true after the file has been
%    processed. Thus for using the name in the file hooks we need to
%    preserve the name and then restored it for the
%    \texttt{file/after/...} hook.
%
%    The hook always refers to the file requested by the user.  The hook
%    is \emph{always} loaded for \cs{CurrentFile} which usually is the
%    same as \cs{CurrentFileUsed}.  In the case of a file replacement,
%    the \cs{CurrentFileUsed} holds the actual file loaded.  In any case
%    the file names are normalised so that the hooks work on the real
%    file name, rather than what the user typed in.
%
%    \pkg{expl3}'s \cs{file_full_name:n} normalizes the file
%    name (to factor out differences in the |.tex| extension), and
%    then does a file lookup to take into account a possible path from
%    \cs{l_file_search_path_seq} and \cs{input@path}.  However only
%    the file name and extension are returned so that file hooks can
%    refer to the file by their name only.  The path to the file is
%    returned in \cs{CurrentFilePath}.
%    \begin{macrocode}
      \edef\reserved@a{\@filef@und
        \@filehook@file@pop@assign
          {\CurrentFilePathUsed}%
          {\CurrentFileUsed}%
          {\CurrentFilePath}%
          {\CurrentFile}}%
      \expandafter\@swaptwoargs\expandafter
        {\reserved@a}%
        {%
          #2%
          \@addtofilelist{#1}%
          \UseHook{file/before}%
%    \end{macrocode}
%    The current file name is available in \cs{@curr@file} so we use
%    that in the specific hook.
%    \begin{macrocode}
          \UseHook{file/before/\CurrentFile}%
          \@@input
        }%
%    \end{macrocode}
%    And it is restored here so we can use it once more.
%    \begin{macrocode}
      \UseHook{file/after/\CurrentFile}%
      \UseHook{file/after}%
      \@filehook@file@pop
    }%
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Declaring a file substitution}
%
%    \begin{macrocode}
\ExplSyntaxOn
%<@@=filehook>
%    \end{macrocode}
%
% \begin{macro}[int]{\use_ii_iii:nnn}
%   A variant of \cs[no-index]{use_...} to discard the first of three
%   arguments.
%    \begin{macrocode}
\cs_gset:Npn \use_ii_iii:nnn #1 #2 #3 {#2 #3}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\declare@file@substitution}
% \begin{macro}{\undeclare@file@substitution}
% \begin{macro}{\@@_subst_file_normalise:n,\@@_subst_empty_name_chk:NN}
%   \cs{declare@file@substitution} declares a file substitution by
%   doing a (global) definition of the form
%   |\def|\cs{@file-subst@\meta{file}}|{|\meta{replacement}|}|.
%   The file names are properly sanitised, and normalised with the same
%   treatment done for the file hooks.  That is, a file replacement is
%   declared by using the file name (and extension, if any) only, and
%   the file path should not be given.  If a file name is empty it is
%   replaced by |.tex| (the empty csname is used to check that).
%    \begin{macrocode}
\cs_new_protected:Npn \declare@file@substitution #1 #2
  {
    \group_begin:
      \cs_set:cpx { } { \exp_not:o { \cs:w\cs_end: } }
      \int_set:Nn \tex_escapechar:D { -1 }
      \cs_gset:cpx { @file-subst@ \@@_subst_file_normalise:n {#1} }
        { \@@_subst_file_normalise:n {#2} }
    \group_end:
  }
\cs_new_protected:Npn \undeclare@file@substitution #1
  {
    \group_begin:
      \cs_set:cpx { } { \exp_not:o { \cs:w\cs_end: } }
      \int_set:Nn \tex_escapechar:D { -1 }
      \cs_undefine:c { @file-subst@ \@@_subst_file_normalise:n {#1} }
    \group_end:
  }
\cs_new:Npn \@@_subst_file_normalise:n #1
  {
    \exp_after:wN \@@_subst_empty_name_chk:NN
      \cs:w \exp_after:wN \cs_end:
        \cs:w \@@_file_parse_full_name:nN {#1} \use_ii_iii:nnn \cs_end:
  }
\cs_new:Npn \@@_subst_empty_name_chk:NN #1 #2
  { \if_meaning:w #1 #2 .tex \else: \token_to_str:N #2 \fi: }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
%    \begin{macrocode}
%<@@=>
\ExplSyntaxOff
%    \end{macrocode}
%
% \subsection{Selecting a file (\cs{set@curr@file})}
%
% \begin{macro}{\set@curr@file,\@filehook@set@CurrentFile}
% \begin{macro}{\@kernel@make@file@csname,\@set@curr@file@aux}
%   Now we hook into \cs{set@curr@file} to resolve a possible file
%   substitution, and add \cs{@filehook@set@curr@file} at the end, after
%   \cs{@curr@file} is set.
%
%   A file name is built using
%   \cs{expandafter}\cs{string}\cs{csname}\meta{filename}\cs{endcsname}
%   to avoid expanding utf8 active characters.  The \cs{csname} expands
%   the normalisation machinery and the routine to resolve a file
%   substitution, returning a control sequence with the same name as the
%   file.
%
%   It happens that when \meta{filename} is empty, the generated control
%   sequence is \cs{csname\cs{endcsname}}, and doing \cs{string} on
%   that results in the file |csnameendcsname.tex|.  To guard against
%   that we \cs{ifx}-compare the generated control sequence with the
%   empty csname.  To do so, \cs{csname\cs{endcsname}} has to be
%   defined, otherwise it would be equal to \cs{relax} and we would have
%   false positives.  Here we define \cs{csname\cs{endcsname}} to
%   expand to itself to avoid it matching the definition of some other
%   control sequence.
%    \begin{macrocode}
\def\set@curr@file#1{%
  \begingroup
    \escapechar\m@ne
    \expandafter\def\csname\expandafter\endcsname
      \expandafter{\csname\endcsname}%
%    \end{macrocode}
%   Two file names are set here: \cs{@curr@file@reqd} which is the file
%   requested by the user, and \cs{@curr@file} which should be the same,
%   except when we have a file substitution, in which case it holds the
%   actual loaded file.  \cs{@curr@file} is resolved first, to check if
%   a substitution happens.  If it doesn't,
%   \cs{@kernel@if@file@replacedTF} short-cuts and just copies
%   \cs{@curr@file}, otherwise the full normalisation procedure is
%   executed.
%    \begin{macrocode}
    \@kernel@make@file@csname\@curr@file
      \@kernel@resolve@file@subst{#1}%
    \@kernel@if@file@replacedTF
      {\@kernel@make@file@csname\@curr@file@reqd
         \@kernel@normalise@file@name{#1}}%
      {\global\let\@curr@file@reqd\@curr@file}%
  \endgroup}
\def\@kernel@make@file@csname#1#2#3{%
  \xdef#1{\expandafter\@set@curr@file@aux
    \csname\expandafter#2\@firstofone#3\@nil\endcsname}}
%    \end{macrocode}
%   This auxiliary compares \cs{\meta{filename}} with
%   \cs{csname\cs{endcsname}} to check if the empty |.tex| file was
%   requested.
%    \begin{macrocode}
\def\@set@curr@file@aux#1{%
  \expandafter\ifx\csname\endcsname#1%
    .tex\else\string#1\fi}
%    \end{macrocode}
%
%   Then we call \cs{@filehook@set@curr@file} once for \cs{@curr@file}
%   to set \cs[no-index]{CurrentFile(Path)Used} and once for
%   \cs{@curr@file@reqd} to set \cs[no-index]{CurrentFile(Path)}.
%   Here too the slower route is only used if a substitution happened,
%   but here \cs{@kernel@if@file@replacedTF} can't be used because the
%   flag is reset at the \cs{endgroup} above, so we check if
%   \cs{@curr@file} and \cs{@curr@file@reqd} differ.  This macro is
%   issued separate from \cs{set@curr@file} because it changes
%   \cs{CurrentFile}, and side-effects would quickly get out of control.
%    \begin{macrocode}
\def\@filehook@set@CurrentFile{%
  \@filehook@set@curr@file{\@curr@file}%
    \CurrentFileUsed\CurrentFilePathUsed
  \ifx\@curr@file@reqd\@curr@file
    \let\CurrentFile\CurrentFileUsed
    \let\CurrentFilePath\CurrentFilePathUsed
  \else
    \@filehook@set@curr@file{\@curr@file@reqd}%
      \CurrentFile\CurrentFilePath
  \fi}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@filehook@set@curr@file,\@@_set_curr_file:nNN}
%   When inputting a file, \cs{set@curr@file} does a file lookup
%   (in \cs{input@path} and \cs{l_file_search_path_seq}) and returns the
%   actual file name (\meta{base} plus \meta{ext}) in
%   \cs{CurrentFileUsed}, and in case there's a file substitution, the
%   requested file in \cs{CurrentFile} (otherwise both are the same).
%   Only the base and extension are returned,
%   regardless of the input (both \texttt{path/to/file.tex} and
%   \texttt{file.tex} end up as \texttt{file.tex} in \cs{CurrentFile}).
%   The path is returned in \cs{CurrentFilePath}, in case it's needed.
%    \begin{macrocode}
\ExplSyntaxOn
%<@@=filehook>
\cs_new_protected:Npn \@filehook@set@curr@file #1
  { \exp_args:NV \@@_set_curr_file:nNN #1 }
\cs_new_protected:Npn \@@_set_curr_file:nNN #1
  {
    \file_parse_full_name_apply:nN {#1}
      \@@_set_curr_file_assign:nnnNN
  }
\cs_new_protected:Npn \@@_set_curr_file_assign:nnnNN #1 #2 #3 #4 #5
  {
    \str_set:Nn #5 {#1}
    \str_set:Nn #4 {#2#3}
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Replacing a file and detecting loops}
%
% \begin{macro}{\@kernel@resolve@file@subst}
% \begin{macro}{\@kernel@normalise@file@name}
% \begin{macro}{\@@_file_name_compose:nnn}
%   Start by sanitising the file with \cs{@@_file_parse_full_name:nN}
%   then do \cs{@@_file_subst_begin:nnn}\Arg{path}\Arg{name}\Arg{ext}.
%    \begin{macrocode}
\cs_new:Npn \@kernel@resolve@file@subst #1 \@nil
  { \@@_file_parse_full_name:nN {#1} \@@_file_subst_begin:nnn }
\cs_new:Npn \@kernel@normalise@file@name #1 \@nil
  { \@@_file_parse_full_name:nN {#1} \@@_file_name_compose:nnn }
\cs_new:Npn \@@_file_name_compose:nnn #1 #2 #3
  { \tl_if_empty:nF {#1} { #1 / } #2#3 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{flag @@_file_replaced}
% \begin{macro}{\@kernel@if@file@replacedTF}
%   Since the file replacement is done expandably in a \cs{csname}, use
%   a flag to remember if a substitution happened.  We use this in
%   \cs{set@curr@file} to short-circuit some of it in case no
%   substitution happened (by far the most common case, so it's worth
%   optimising).
%    \begin{macrocode}
\flag_new:n { @@_file_replaced }
\cs_new:Npn \@kernel@if@file@replacedTF #1 #2
  { \flag_if_raised:nTF { @@_file_replaced } {#1} {#2} }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_file_subst_begin:nnn}
%   First off, start by checking if the current file ($\meta{name} +
%   \meta{ext}$) has a declared substitution.  If not, then just put
%   that as the name (including a possible \meta{path} in this case):
%   this is the default case with no substitutions, so it's the first to
%   be checked.  The auxiliary \cs{@@_file_subst_tortoise_hare:nn} sees
%   that there's no replacement for |#2#3| and does nothing else.
%    \begin{macrocode}
\cs_new:Npn \@@_file_subst_begin:nnn #1 #2 #3
  {
    \@@_file_subst_tortoise_hare:nn { #2#3 } { #2#3 }
      { \@@_file_name_compose:nnn {#1} {#2} {#3} }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{The Tortoise and Hare algorithm}
%
% \begin{macro}{\@@_file_subst_tortoise_hare:nn}
% \begin{macro}{\@@_file_subst_loop:NN,\@@_file_subst_loop:cc}
%   If there is a substitution (\meta{true} in the first
%   \cs{cs_if_exist:cTF} below), then first check if there is no
%   substitution down the line:  this should be the second most common
%   case, of one file replaced by another.  In that case just leave the
%   substitution there and the job is done.  If any substitution
%   happens, then the \cs{flag @@_file_replaced} is raised
%   (conditionally, because checking if a flag is raised is much faster
%   than raising it over and over again).
%
%   If, however there are more substitutions, then we need to check for
%   a possible loop in the substitutions, which would otherwise put
%   \TeX{} in an infinite loop if just an exhaustive expansion was used.
%
%   To detect a loop, the \emph{Tortoise and Hare} algorithm is used.
%   The name of the algorithm is an analogy to Aesop's fable, in which
%   the Hare outruns a Tortoise.  The two pointers here are the csnames
%   which contains each file replacement, both of which start at the
%   position zero, which is the file requested.  In the inner part of
%   the macro below, \cs{@@_file_subst_loop:cc} is called with
%   \cs[no-index]{@file-subst@\meta{file}} and
%   \cs[no-index]{@file-subst@\cs[no-index]{@file-subst@\meta{file}}};
%   that is, the substitution of \meta{file} and the substution of that
%   substution:  the Tortoise walks one step while the Hare walks two.
%
%   Within \cs{@@_file_subst_loop:NN} the two substitutions are
%   compared, and if they lead to the same file it means that there is
%   a loop in the substitutions.  If there's no loop,
%   \cs{@@_file_subst_tortoise_hare:nn} is called again with the
%   Tortoise at position~1 and the hare at~2.  Again, the substitutions
%   are checked ahead of the Hare pointer to check that it won't run too
%   far;  in case there is no loop in the declarations, eventually one
%   of the \cs{cs_if_exist:cTF} below will go \meta{false} and the
%   algorithm will end;  otherwise it will run until the Hare reaches
%   the same spot as the tortoise and a loop is detected.
%    \begin{macrocode}
\cs_new:Npn \@@_file_subst_tortoise_hare:nn #1 #2 #3
  {
    \cs_if_exist:cTF { @file-subst@ #2 }
      {
        \flag_if_raised:nF { @@_file_replaced }
          { \flag_raise:n { @@_file_replaced } }
        \cs_if_exist:cTF { @file-subst@ \use:c { @file-subst@ #2 } }
          {
            \@@_file_subst_loop:cc
              { @file-subst@ #1 }
              { @file-subst@ \use:c { @file-subst@ #2 } }
          }
          { \use:c { @file-subst@ #2 } }
      }
      { #3 }
  }
%    \end{macrocode}
%   This is just an auxiliary to check if a loop was found, and continue
%   the algorithm otherwise.  If a loop is found, the |.tex| file is
%   used as fallback and \cs{@@_file_subst_cycle_error:cN} is called to
%   report the error.
%    \begin{macrocode}
\cs_new:Npn \@@_file_subst_loop:NN #1 #2
  {
    \token_if_eq_meaning:NNTF #1 #2
      {
        .tex
        \@@_file_subst_cycle_error:cN { @file-subst@ #1 } #1
      }
      { \@@_file_subst_tortoise_hare:nn {#1} {#2} {#2} }
  }
\cs_generate_variant:Nn \@@_file_subst_loop:NN { cc }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{
%     \@@_file_subst_cycle_error:NN,
%     \@@_file_subst_cycle_error:cN,
%   }
%   Showing this type of error expandably is tricky, as we have a very
%   limited amount of characters to show and a potentially large list.
%   As a work around, several errors are printed, each showing one step
%   of the loop, until all the error messages combined show the loop.
%    \begin{macrocode}
\cs_new:Npn \@@_file_subst_cycle_error:NN #1 #2
  {
    \__kernel_msg_expandable_error:nnff { kernel } { file-cycle }
      {#1} { \use:c { @file-subst@ #1 } }
    \token_if_eq_meaning:NNF #1 #2
      { \@@_file_subst_cycle_error:cN { @file-subst@ #1 } #2 }
  }
\cs_generate_variant:Nn \@@_file_subst_cycle_error:NN { c }
%    \end{macrocode}
%
%   And the error message:
%    \begin{macrocode}
\__kernel_msg_new:nnn { kernel } { file-cycle }
  { File~loop!~#1~replaced~by~#2... }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%    \begin{macrocode}
\ExplSyntaxOff
%<@@=>
%    \end{macrocode}
%
% \begin{macro}{\@missingfileerror}
%   Changes to \cs{@missingfileerror}:  rather than trying to input the
%   file by force, now \cs{@missingfileerror} just returns three
%   \cs[no-index]{@missingfile@\meta{part}} and the caller macro is
%   responsible for doing the right thing with it.
%    \begin{macrocode}
\gdef\@missingfileerror#1#2{%
     \typeout{^^J! LaTeX Error: File `#1.#2' not found.^^J^^J%
      Type X to quit or <RETURN> to proceed,^^J%
      or enter new name. (Default extension: #2)^^J}%
     \message{Enter file name: }%
      {\endlinechar\m@ne
       \global\read\m@ne to\@gtempa}%
    \ifx\@gtempa\@empty
%    \end{macrocode}
%   If the user answers with \meta{return}, fallback to the |.tex| file
%   (previously it did nothing).
%    \begin{macrocode}
      \let\@missingfile@area\@empty
      \let\@missingfile@base\@empty
      \def\@missingfile@ext{tex}%
    \else
%    \end{macrocode}
%   Use \cs{batchmode}\cs{read}|-1 to |\meta{tl} to end the \TeX{} run,
%   same as \pkg{expl3} does (it was \cs{batchmode}\cs{@@end} before).
%    \begin{macrocode}
      \def\reserved@b{\batchmode\read-1 to \reserved@a}%
      \def\reserved@a{x}\ifx\reserved@a\@gtempa\reserved@b\fi
      \def\reserved@a{X}\ifx\reserved@a\@gtempa\reserved@b\fi
      \filename@parse\@gtempa
      \edef\filename@ext{%
        \ifx\filename@ext\relax#2\else\filename@ext\fi}%
     \edef\reserved@a{%
%    \end{macrocode}
%   Only check \cs{IfFileExists} (it was \cs{InputIfFileExists}).
%    \begin{macrocode}
       \noexpand\IfFileExists
         {\filename@area\filename@base.\filename@ext}%
%    \end{macrocode}
%   If the file exists, define \cs[no-index]{@missingfile@\meta{part}}.
%    \begin{macrocode}
         {\def\noexpand\@missingfile@area{\filename@area}%
          \def\noexpand\@missingfile@base{\filename@base}%
          \def\noexpand\@missingfile@ext {\filename@ext}}%
         {\noexpand\@missingfileerror
            {\filename@area\filename@base}{\filename@ext}}}%
      \reserved@a
    \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@iinput}
%   Changes to \cs{@iinput}: adapt to the changes to
%   \cs{@missingfileerror}.
%    \begin{macrocode}
\def\@iinput#1{%
  \InputIfFileExists{#1}{}%
  {\filename@parse\@curr@file
   \edef\reserved@a{\noexpand\@missingfileerror
     {\filename@area\filename@base}%
     {\ifx\filename@ext\relax tex\else\filename@ext\fi}}%
%    \end{macrocode}
%   This line now just sets \cs[no-index]{@missingfile@\meta{part}}:
%    \begin{macrocode}
   \reserved@a
%    \end{macrocode}
%   Now here we have to use it.  The file here is guaranteed to exist,
%   because \cs{@missingfileerror} ensures so, but we have to use
%   \cs{InputIfFileExists} because it executes the file hooks.
%    \begin{macrocode}
   \edef\reserved@a{\noexpand\@iinput{%
     \@missingfile@area\@missingfile@base.\@missingfile@ext}}%
   \reserved@a}}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Preventing a package/class from loading}
%
% \begin{macro}{\disable@package@load}
% \begin{macro}{\@disable@packageload@do}
%   \cs{disable@package@load} defines
%   \cs[no-index]{@pkg-disable@\meta{package}} to expand to some code |#2|
%   instead of loading the package.
%    \begin{macrocode}
\def\disable@package@load#1#2{%
  \global\@namedef{@pkg-disable@#1.\@pkgextension}{#2}}
\def\@disable@packageload@do#1#2{%
  \@ifundefined{@pkg-disable@#1}{#2}%
     {\@nameuse{@pkg-disable@#1}}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\reenable@package@load}
%   \cs{reenable@package@load} undefines
%   \cs[no-index]{@pkg-disable@\meta{package}} to reallow loading a package.
%    \begin{macrocode}
\def\reenable@package@load#1{%
  \global\expandafter\let
  \csname @pkg-disable@#1.\@pkgextension \endcsname \@undefined}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\load@onefilewithoptions,\load@onefile@withoptions}
% \begin{macro}{\@missing@onefilewithoptions}
%   This macro is used when loading packages or classes.
%    \begin{macrocode}
\def\load@onefilewithoptions#1[#2][#3]#4{%
  \@pushfilename
  \xdef\@currname{#1}%
  \global\let\@currext#4%
%    \end{macrocode}
%   The command \cs{ver@\meta{file}.\meta{ext}} is used to signal that
%   a package is already loaded, either because it is in fact loaded, or
%   because it's loading was suppressed.  In minimal installations, said
%   package may not exist but still have its loading suppressed with
%   \cs{ver@\meta{file}.\meta{ext}}, so before checking if the file
%   exists we have to check that we do need to load it with
%   \cs{@ifl@aded}.  If we don't, then there's no point in checking for
%   a typo or load-disabling.
%    \begin{macrocode}
  \@ifl@aded\@currext\@currname
%    \end{macrocode}
%   If the package is already loaded, check that there were no option
%   clashes:
%    \begin{macrocode}
    {\@if@ptions\@currext{\@currname}{#2}{}%
      {\@latex@error
        {Option clash for \@cls@pkg\space \@currname}%
        {The package \@currname\space has already been loaded
         with options:\MessageBreak
         \space\space[\@ptionlist{\@currname.\@currext}]\MessageBreak
         There has now been an attempt to load it
          with options\MessageBreak
         \space\space[#2]\MessageBreak
         Adding the global options:\MessageBreak
         \space\space
              \@ptionlist{\@currname.\@currext},#2\MessageBreak
         to your \noexpand\documentclass declaration may fix this.%
         \MessageBreak
         Try typing \space <return> \space to proceed.}}%
     \@firstofone}%
    {\@reset@ptions
     \makeatletter
%    \end{macrocode}
%   First we take the \meta{name} and \meta{ext} given in the argument
%   and check if the file exists, and issue an error otherwise asking
%   for a correction with \cs{@missingfileerror}.
%    \begin{macrocode}
     \IfFileExists{\@currname.\@currext}{}%
       {\@missing@onefilewithoptions{#2}}%
%    \end{macrocode}
%   If \cs{@currname} is empty (the user replied to the ``Enter file
%   name'' prompt with \meta{RETURN}), so stop here
%   (do \cs{@popfilename} to pop the item just added above).
%
%   This \cs{@gobble} omits the date check at the end.
%    \begin{macrocode}
     \ifx\@currname\@empty
       \expandafter\@gobble
     \else
%    \end{macrocode}
%   If the file exists, check if it was load-prevented, and otherwise
%   do the bookkeeping with \cs{@filehook@file@push}
%   then call \cs{set@curr@file} to set \cs{@curr@file} (and do any
%   required substitution), then actually load the class/package with
%   \cs{load@onefile@withoptions}.
%    \begin{macrocode}
       \@disable@packageload@do{\@currname.\@currext}%
         {\@filehook@file@push
          \set@curr@file{\@currname.\@currext}%
          \@filehook@set@CurrentFile
          \load@onefile@withoptions{#2}%
%    \end{macrocode}
%   Now just clean up and exit.
%    \begin{macrocode}
          \@filehook@file@pop}%
       \@reset@ptions
       \expandafter\@firstofone
     \fi}%
%    \end{macrocode}
%   Except in the case where \cs{@currname} is empty, the date is
%   checked against the date marked in the package file:
%    \begin{macrocode}
    {\@ifl@ter\@currext{\@currname}{#3}{}%
      {\@latex@warning@no@line
        {You have requested,\on@line,
         version\MessageBreak
           `#3' of \@cls@pkg\space \@currname,\MessageBreak
         but only version\MessageBreak
          `\csname ver@\@currname.\@currext\endcsname'\MessageBreak
         is available}}%
     \ifx\@currext\@clsextension\let\LoadClass\@twoloadclasserror\fi}%
  \@popfilename}
%    \end{macrocode}
%
%   Now the action taken when a file is not found.
%    \begin{macrocode}
\def\@missing@onefilewithoptions#1{%
  \@missingfileerror\@currname\@currext
  \xdef\@currname{\@missingfile@area\@missingfile@base}%
  \global\let\@currext\@missingfile@ext}
%    \end{macrocode}
%
%   Now the code that actually does the file loading:
%    \begin{macrocode}
\def\load@onefile@withoptions#1{%
  \let\CurrentOption\@empty
  \@reset@ptions
  \def\reserved@a{%
    \@pass@ptions\@currext{#1}{\@currname}%
    \global\expandafter
    \let\csname ver@\@currname.\@currext\endcsname\@empty
    \expandafter\let\csname\@currname.\@currext-h@@k\endcsname\@empty
%-----------------------------------------
%    \end{macrocode}
%    When the current extension is \cs{@pkgextension} we are loading a
%    package otherwise, if it is \cs{@clsextension}, a class, so
%    depending on that we execute different hooks.  If the extension is
%    neither, then it is another type of file without special hooks.
%    \begin{macrocode}
    \ifx\@currext\@pkgextension
      \UseHook{package/before}%
      \UseHook{package/before/\@currname}%
    \else
      \ifx\@currext\@clsextension
        \UseHook{class/before}%
        \UseHook{class/before/\@currname}%
      \fi
    \fi
%    \end{macrocode}
%    Now actually load the file (at this point we are certain it exists,
%    but use \cs{InputIfFileExists} so tha file hooks are executed):
%    \begin{macrocode}
    \InputIfFileExists{\@currname.\@currext}{}{}%
    \let\@unprocessedoptions\@@unprocessedoptions
    \csname\@currname.\@currext-h@@k\endcsname
    \expandafter\let\csname\@currname.\@currext-h@@k\endcsname
              \@undefined
%-----------------------------------------
%    \end{macrocode}
%    And same procedure, James, when we are finished loading, except
%    that the hook order is now reversed.
%    \begin{macrocode}
    \ifx\@currext\@pkgextension
      \UseHook{package/after/\@currname}%
      \UseHook{package/after}%
    \else
      \ifx\@currext\@clsextension
        \UseHook{class/after/\@currname}%
        \UseHook{class/after}%
      \fi
    \fi
%-----------------------------------------
    \@unprocessedoptions}%
  \reserved@a}
%    \end{macrocode}
%
%    The code for this macro has changed between 2020/02/02 and
%    2020/10/01 so the never version is this:
%    \begin{macrocode}
\@ifl@t@r\fmtversion{2020/10/01}
{%
\def\load@onefile@withoptions#1{%
  \let\CurrentOption\@empty
  \@reset@ptions
  \def\reserved@a{%
    \@pass@ptions\@currext{#1}{\@currname}%
    \global\expandafter
    \let\csname ver@\@currname.\@currext\endcsname\@empty
    \expandafter\let\csname\@currname.\@currext-h@@k\endcsname\@empty
%-----------------------------------------
    \ifx\@currext\@pkgextension
      \UseHook{package/before}%
      \UseHook{package/before/\@currname}%
    \else
      \ifx\@currext\@clsextension
        \UseHook{class/before}%
        \UseHook{class/before/\@currname}%
      \fi
    \fi
    \InputIfFileExists{\@currname.\@currext}{}{}%
%-----------------------------------------
    \expandafter\let\csname unprocessedoptions-\@currname.\@currext\endcsname
                    \@@unprocessedoptions
    \csname\@currname.\@currext-h@@k\endcsname
    \expandafter\let\csname\@currname.\@currext-h@@k\endcsname
              \@undefined
    \ifx\@unprocessedoptions\relax
      \let\@unprocessedoptions\@undefined
    \else
      \csname unprocessedoptions-\@currname.\@currext\endcsname
    \fi
    \expandafter\let
        \csname unprocessedoptions-\@currname.\@currext\endcsname
       \@undefined
%-----------------------------------------
    \ifx\@currext\@pkgextension
      \UseHook{package/after/\@currname}%
      \UseHook{package/after}%
    \else
      \ifx\@currext\@clsextension
        \UseHook{class/after/\@currname}%
        \UseHook{class/after}%
      \fi
    \fi}%
%-----------------------------------------
  \reserved@a}
}{}%
%    \end{macrocode}
%  \end{macro}
%  \end{macro}


%
%
% \subsection{High-level interfaces for \LaTeX{}}
%
%    None so far and the general feeling for now is that the hooks are
%    enough. Packages like \pkg{filehook}, etc., may use them to set
%    up their interfaces (samples are given below) but for the now the
%    kernel will not provide any.
%
%
%    \begin{macrocode}
%</2ekernel>
%    \end{macrocode}
%
%
%
% \section{Package emulation for compatibility}
%
%
% \subsection{Package \pkg{filehook} emulation}
%
%    This is a partial implementation of the  \pkg{filehook}
%    interfaces. It is only meant for guidance in case that package
%    gets updated to use the hook management.
%
%    Not implemented are:
%\begin{verbatim}
%  \AtBeginOfFiles
%  \AtEndOfFiles
%  \AtBeginOfInputs
%  \AtEndOfInputs
%  \AtBeginOfInputFile
%  \AtEndOfInputFile
%\end{verbatim}
%
%    \begin{macrocode}
%<*filehook-draft>
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand\AtBeginOfEveryFile [1]
  {\AddToHook{file/before}{#1}}
\newcommand\AtEndOfEveryFile [1]
  {\AddToHook{file/after}{#1}}
%    \end{macrocode}
%    
%    \begin{macrocode}
\newcommand\AtBeginOfIncludes [1]
  {\AddToHook{include/before}{#1}}
\newcommand\AtEndOfIncludes [1]
  {\AddToHook{include/end}{#1}}
\newcommand\AfterIncludes [1]
  {\AddToHook{include/after}{#1}}
%    \end{macrocode}
%    
%    \begin{macrocode}
\newcommand\AtBeginOfPackages [1]
  {\AddToHook{package/before}{#1}}
\newcommand\AtEndOfPackages [1]
  {\AddToHook{package/after}{#1}}
%    \end{macrocode}
%    
%    \begin{macrocode}
\newcommand\AtBeginOfClasses [1]
  {\AddToHook{class/before}{#1}}
\newcommand\AtEndOfClasses [1]
  {\AddToHook{class/after}{#1}}
%    \end{macrocode}
%
%    For normal files we drop the \texttt{.tex} extension for now:
%    \begin{macrocode}
\newcommand\AtBeginOfFile [2]
  {\AddToHook{file/before/#1}{#2}}
\newcommand\AtEndOfFile [2]
  {\AddToHook{file/after/#1}{#2}}
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareDocumentCommand \AtBeginOfPackageFile {smm}
   {\IfBooleanTF{#1}%
     {\@ifpackageloaded{#2}%
         {#3}%
         {\AddToHook{package/before/#2}{#3}}}%
     {\AddToHook{package/before/#2}{#3}}%
   }
\DeclareDocumentCommand \AtEndOfPackageFile {smm}
   {\IfBooleanTF{#1}%
     {\@ifpackageloaded{#2}%
         {#3}%
         {\AddToHook{package/after/#2}{#3}}}%
     {\AddToHook{package/after/#2}{#3}}%
   }
%    \end{macrocode}
%
%    Are the * forms here of any use? I know they are use 3--4 times
%    on CTAN but I wonder if those are real or mistaken usages.  
%    \begin{macrocode}
\DeclareDocumentCommand \AtBeginOfClassFile {smm}
   {\IfBooleanTF{#1}%
     {\@ifclassloaded{#2}%
         {#3}%
         {\AddToHook{class/before/#2}{#3}}}%
     {\AddToHook{class/before/#2}{#3}}%
   }
\DeclareDocumentCommand \AtEndOfClassFile {smm}
   {\IfBooleanTF{#1}%
     {\@ifclassloaded{#2}%
         {#3}%
         {\AddToHook{class/after/#2}{#3}}}%
     {\AddToHook{class/after/#2}{#3}}%
   }
%    \end{macrocode}
%    
%    \begin{macrocode}
\newcommand\AtBeginOfIncludeFile [2]
  {\AddToHook{include/before/#1}{#2}}
\newcommand\AtEndOfIncludeFile [2]
  {\AddToHook{include/end/#1}{#2}}
\newcommand\AfterIncludeFile [2]
  {\AddToHook{include/after/#1}{#2}}
%    \end{macrocode}
%
%
%    This is missing some interfaces so disabling the package isn't
%    really correct, but then this code above is not supposed to stay
%    like this anyway.
%    \begin{macrocode}
\expandafter\let\csname ver@filehook.sty\endcsname\fmtversion
\@namedef {ver@filehook.sty}{2020/10/01}
%    \end{macrocode}
%
%
%    \begin{macrocode}
%</filehook-draft>
%    \end{macrocode}
%
%
%
%
% \subsection{Package \pkg{scrlfile} emulation}
%
%    This is a partial implementation of the  \pkg{scrlfile}
%    interfaces. It is only meant for guidance in case that package
%    gets updated to use the hook management.
%
%    \begin{macrocode}
%<*scrlfile-draft>
%    \end{macrocode}
%
%    I think this is roughly correct (using the \texttt{file/...}
%    hooks rather than the class or package hooks at least for the
%    \cs{After...} commands but it needs some further verification.
%
%    The star and plus variants haven't been implemented so far, this
%    is only a rough draft.
%    \begin{macrocode}
\newcommand\BeforeClass[2]
  {\AddToHook{file/before/#1.cls}{#2}}
\newcommand\AfterClass [2]
  {\AddToHook{file/after/#1.cls}{#2}}
\newcommand\AfterAtEndOfClass [2]
  {\AddToHook{class/after/#1}{#2}}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand\BeforePackage [2]
  {\AddToHook{package/before/#1.sty}{#2}}
\newcommand\AfterPackage [2]
  {\AddToHook{file/after/#1.sty}{#2}}
\newcommand\AfterEndOfPackage [2]
  {\AddToHook{package/after/#1}{#2}}
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand\BeforeFile [2]
  {%
  \typeout{BeforeFile: #1!!!}%
   \AddToHook{file/before/#1}{#2}}
\newcommand\AfterFile [2]
  {%
    \typeout{AfterFile: #1!!!}%
    \AddToHook{file/after/#1}{#2}}
%    \end{macrocode}
%
%    This is missing some interfaces so disabling the package isn't
%    really correct, but then this code above is not supposed to stay
%    like this anyway.
%    \begin{macrocode}
\expandafter\let\csname ver@scrlfile.sty\endcsname\fmtversion
\@namedef {ver@scrlfile.sty}{2020/10/01}
%    \end{macrocode}
%
%    \begin{macrocode}
%</scrlfile-draft>
%    \end{macrocode}
%
%
%
% \section{A sample package for structuring the log output}
%
%    \begin{macrocode}
%<*structuredlog>
%<@@=filehook>
%    \end{macrocode}
%
%    \begin{macrocode}
\ProvidesExplPackage
    {structuredlog}{\ltfilehookdate}{\ltfilehookversion}
    {Structuring the TeX transcript file}
%    \end{macrocode}
%
% \begin{macro}{\g_@@_nesting_level_int}
%   Stores the current package nesting level.
%    \begin{macrocode}
\int_new:N \g_@@_nesting_level_int
%    \end{macrocode}
%   Initialise the counter with the number of files in the
%   \cs{@currnamestack} (the number of items divided by $3$) minus one,
%   because this package is skipped when printing to the log.
%    \begin{macrocode}
\int_gset:Nn \g_@@_nesting_level_int
  { ( \tl_count:N \@currnamestack ) / 3 - 1 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_log_file_record:n}
%   This macro is responsible for increasing and decresing the file
%   nesting level, as well as printing to the log.  The argument is
%   either |STOPTART| or |STOP| and the action it takes on the nesting
%   integer depends on that.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_log_file_record:n #1
  {
    \str_if_eq:nnT {#1} {START} { \int_gincr:N \g_@@_nesting_level_int }
    \iow_term:x
      {
        \prg_replicate:nn { \g_@@_nesting_level_int } { = } ~
        ( LEVEL ~ \int_use:N \g_@@_nesting_level_int \c_space_tl #1 ) ~
        \CurrentFileUsed
%    \end{macrocode}
%   If there was a file replacement, show that as well:
%    \begin{macrocode}
        \str_if_eq:NNF \CurrentFileUsed \CurrentFile
          { ~ ( \CurrentFile \space requested ) }
        \iow_newline:
      }
    \str_if_eq:nnT {#1} {STOP} { \int_gdecr:N \g_@@_nesting_level_int }
  }
%    \end{macrocode}
%
%   Now just hook the macro above in the generic |file/before|\ldots
%    \begin{macrocode}
\AddToHook{file/before}{ \@@_log_file_record:n { START } }
%    \end{macrocode}
%   \ldots and |file/after| hooks.
%   We don't want to install the \hook{file/after} hook immediately,
%   because that would mean it is the first time executed when the
%   package finishes. We therefore put the declaration inside
%   \cs{AddToHookNext} so that it gets only installed when we have
%   left this package.
%    \begin{macrocode}
\AddToHookNext{file/after}
  { \AddToHook{file/after}{ \@@_log_file_record:n { STOP } } }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%<@@=>
%</structuredlog>
%    \end{macrocode}

%    \Finale
%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
\endinput
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  


