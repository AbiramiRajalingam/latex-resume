
% \section{Changing the font series}
%
% \emph{write intro}
%
%  \begin{macro}{\DeclareFontSeriesChangeRule}
%    The \cs{DeclareFontSeriesChangeRule} defines entries in a simple
%    database (implemented as a set of commands) that define mappings
%    between from an existing series and requested new series and maps
%    that to  a result series (and additionally offers an alternative
%    if the desired one is not existing):
%    \begin{itemize}
%    \item[\texttt{\#1}] current \cs{f@series}
%    \item[\texttt{\#2}] requested new series
%    \item[\texttt{\#3}] result (if that exist for the given font family
%    \item[\texttt{\#4}] alternative result (if \textt{\#3} does not exist)
%    \end{itemize}
%    If an \texttt{.fd} file has its own substitution rules then
%    \texttt{\#3} exist and thus \textt{\#4} is not applied.
%
%    If there is no matching database entry or if neither the result
%    nor the alternate result exist in the font family the requested
%    new series is used (which then may trigger substitutions later on.
%    \begin{macrocode}
\def\DeclareFontSeriesChangeRule#1#2#3#4{%
  \@namedef{series@#1@#2}{{#3}{#4}}}
%    \end{macrocode}
%  \end{macro}
%
% \subsection{Mappin rules for series changes}
%
% The rules set up use explicit series values not \cs{..default}
% indirections; my current feeling is that this is in fact better.
%
% With 9 weights and 9 width classes this table is getting a bit large
% in the end (324 entries) but on the other hand it doesn't change and
% accessing speed and it is not \emph{that} large.
%
% \emph{What is missing so far, is a way to state that I want to revert, say
% the weight to ``regular'' but keep the width or vize versa. That
% would probably need a new letter due to the double use of ``m''. ---
%    not quite sure what I meant when I wrote that sentence!}
%
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {m}{c}  {c}  {m}
\DeclareFontSeriesChangeRule {m}{x}  {x}  {m}
\DeclareFontSeriesChangeRule {m}{m}  {m}  {}
\DeclareFontSeriesChangeRule {m}{b}  {b}  {bx}
\DeclareFontSeriesChangeRule {m}{bx} {bx} {b}
\DeclareFontSeriesChangeRule {m}{l}  {l}  {m}
\DeclareFontSeriesChangeRule {m}{sb} {sb} {b}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {b}{c}  {bc}  {b}
\DeclareFontSeriesChangeRule {b}{x}  {bx}  {b}
\DeclareFontSeriesChangeRule {b}{m}  {m}   {}
\DeclareFontSeriesChangeRule {b}{b}  {b}   {bx}
\DeclareFontSeriesChangeRule {b}{bx} {bx}  {b}
\DeclareFontSeriesChangeRule {b}{l}  {l}   {}
\DeclareFontSeriesChangeRule {b}{sb} {sb}  {b}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {bx}{c}  {bc}  {bx}
\DeclareFontSeriesChangeRule {bx}{x}  {bx}  {}
\DeclareFontSeriesChangeRule {bx}{m}  {m}   {}
\DeclareFontSeriesChangeRule {bx}{b}  {b}   {bx}
\DeclareFontSeriesChangeRule {bx}{bx} {bx}  {}
\DeclareFontSeriesChangeRule {bx}{l}  {lx}  {}
\DeclareFontSeriesChangeRule {bx}{sb} {sbx} {sb}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {l}{c}  {lc}  {l}  % ?
\DeclareFontSeriesChangeRule {l}{x}  {lx}  {l}  % ?
\DeclareFontSeriesChangeRule {l}{m}  {m}   {}
\DeclareFontSeriesChangeRule {l}{b}  {b}   {bx}
\DeclareFontSeriesChangeRule {l}{bx} {bx}  {b}
\DeclareFontSeriesChangeRule {l}{l}  {l}   {}
\DeclareFontSeriesChangeRule {l}{sb} {sb}  {b}  % ?
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {sb}{c}  {sbc} {bc} %?
\DeclareFontSeriesChangeRule {sb}{x}  {sbx} {bx} %?
\DeclareFontSeriesChangeRule {sb}{m}  {m}   {}
\DeclareFontSeriesChangeRule {sb}{b}  {b}   {}
\DeclareFontSeriesChangeRule {sb}{bx} {bx}  {}
\DeclareFontSeriesChangeRule {sb}{l}  {l}   {}
\DeclareFontSeriesChangeRule {sb}{sb} {sb}  {}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {l}{c}  {c}  {m}  % ?
%    \end{macrocode}
%
%
% \emph{rules need to get completed!}
%
%

% \subsection{Changing to a new series}
%
%  \begin{macro}{\fontseries}
%    The \cs{fontseries} command takes one argument which is the requested new
%    font series. In the orginal implementation  it simply saved the
%    expanded value in \cs{f@series}. Now we do a bit more processing
%    and look up the final value in the font series data base. This is
%    done by \cs{merge@font@series}.
%    \begin{macrocode}
\DeclareRobustCommand\fontseries[1]{\merge@font@series{#1}}
%    \end{macrocode}
%  \end{macro}


%  \begin{macro}{\merge@font@series}
%    We look up the data base value by expanding the right command
%    twice. If no such value exist then the result will be \cs{relax}
%    otherwise it will be the two brace groups: the desired result and
%    the alternate result. The first case means that the third
%    argument to \cs{merge@font@series} will be empty.
%    \begin{macrocode}
\def\merge@font@series#1{%
  \expandafter\expandafter\expandafter
  \merge@font@series@
    \csname series@\f@series @#1\endcsname
    {#1}%
    \@nil
}  
%    \end{macrocode}
%  \end{macro}


%  \begin{macro}{merge@font@series@}
%    This now defines the new \cs{f@series}:
%    \begin{macrocode}
\def\merge@font@series@#1#2#3\@nil{%
  \def\@reserveda{#3}%
  \edef\f@series{%
%    \end{macrocode}
%    If the third argument is empty there is no database entry for the
%    combination and the second argument holds the new series so we
%    return that.
%
%    Originally the test was simply \verb=\ifx!#3!= but that actually
%    dies if \texttt{\#3} starts with a conditional and in the
%    definition of \cs{AmSfont} that is actually the case.
%    \begin{macrocode}
    \ifx\@reserveda\@empty
      #2%
    \else
%    \end{macrocode}
%    Otherwise we check if the desired result for the series
%    (\texttt{\#1}) exists for the font family and the current shape.
%    \begin{macrocode}
      \expandafter \ifx
           \csname \f@encoding /\f@family /#1/\f@shape \endcsname
           \relax
%    \end{macrocode}
%    If not, then we try the alternate result (\texttt{\#2}).
%    \begin{macrocode}
         \expandafter \ifx
               \csname \f@encoding /\f@family /#2/\f@shape \endcsname
               \relax
%    \end{macrocode}
%    If that doesn't exist either, then we use the requested series unmodified.
%    \begin{macrocode}
           #3%
%    \end{macrocode}
%    If the alternate result exist we use that
%    \begin{macrocode}
         \else
           #2%
         \fi
%    \end{macrocode}
%    and if the desired result is available then we use that:
%    \begin{macrocode}
      \else
         #1%
      \fi
    \fi
}}
%    \end{macrocode}
%  \end{macro}




% \section{Changing the  shape}
%
%    Rules for managing shapes (i.e., essentially building in an ``sc''
%    axis).
%
% \emph{write intro}
%
%  \begin{macro}{\DeclareFontShapeChangeRule}
%    The database for shapes is done in exactly the same way, only
%    that it is much smaller and we usually have no alternative shape
%    (or rather it is empty thus not used).
%    \begin{macrocode}
\def\DeclareFontShapeChangeRule #1#2#3#4{%
  \@namedef{shape@#1@#2}{{#3}{#4}}}
%    \end{macrocode}
%  \end{macro}
%
%
%    There is kind of the same problem with returning back from
%    \texttt{sc} to normal. It sort of needs its own letter.  In
%    fontspec this is solved by the first time \cs{upshape} changes
%    \texttt{it} or \texttt{sl} back (so only \texttt{sc} remains) and
%    second time it changes then \texttt{sc} back to normal.  Maybe
%    that's not a bad way to handle it, so I've done that below too.
%    The alternative would be to provide something like \cs{noscshape}
%    as the \pkg{slantsc} package does.
%
%    That sort of approach doesn't seem possible with the series as
%    \cs{bfseries} produces \texttt{bx} (normally) and \cs{mdseries}
%    reverts that back to \texttt{{m} (ie no bold and normal width)
%    and I think that needs to be preserved.
%
%  \begin{macro}{\ulcshape}
%    To request going back to upper/lowercase we need a new
%    command. It uses \texttt{ulc} as shape name but this shape is
%    virtual, i.e., it doesn't exist as a real shape, it is only used
%    as part of the database table entries and thus only appears in
%    the second argument there (but not in the first).
%    \begin{macrocode}
\DeclareRobustCommand\ulcshape
        {\not@math@alphabet\ulcshape\relax
         \fontshape{ulc}\selectfont}
\DeclareTextFontCommand{\textulc}{\ulcshape}  % back to upper/lower case
%    \end{macrocode}
%  \end{macro}
%
%
%
% \subsection{Mapping rules for shape combinations}

%    \begin{macrocode}
\DeclareFontShapeChangeRule {n}{n}   {n}   {}
\DeclareFontShapeChangeRule {n}{it}  {it}  {sl}
\DeclareFontShapeChangeRule {n}{sl}  {sl}  {it}
\DeclareFontShapeChangeRule {n}{sc}  {sc}  {}
\DeclareFontShapeChangeRule {n}{ulc} {n}   {}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareFontShapeChangeRule {it}{n}   {n}     {}
\DeclareFontShapeChangeRule {it}{it}  {it}    {}
\DeclareFontShapeChangeRule {it}{sl}  {sl}    {it}
\DeclareFontShapeChangeRule {it}{sc}  {scit}  {scsl}  % or sc or it as second default?
\DeclareFontShapeChangeRule {it}{ulc} {it}    {}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareFontShapeChangeRule {sl}{n}   {n}     {}
\DeclareFontShapeChangeRule {sl}{it}  {it}    {sl}
\DeclareFontShapeChangeRule {sl}{sl}  {sl}    {}
\DeclareFontShapeChangeRule {sl}{sc}  {scsl}  {scit}  % sc or sl as second default?
\DeclareFontShapeChangeRule {sl}{ulc} {sl}    {}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareFontShapeChangeRule {sc}{n}   {n}     {}
\DeclareFontShapeChangeRule {sc}{it}  {scit}  {scsl}
\DeclareFontShapeChangeRule {sc}{sl}  {scsl}  {scit}
\DeclareFontShapeChangeRule {sc}{sc}  {sc}    {}
\DeclareFontShapeChangeRule {sc}{ulc} {n}     {}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareFontShapeChangeRule {scit}{n}   {sc}    {}
\DeclareFontShapeChangeRule {scit}{it}  {scit}  {}
\DeclareFontShapeChangeRule {scit}{sl}  {scsl}  {scit}
\DeclareFontShapeChangeRule {scit}{sc}  {scit}  {}
\DeclareFontShapeChangeRule {scit}{ulc} {it}    {}
%    \end{macrocode}
%    The previous rule assumes that if \texttt{scit} exists then
%    \texttt{it} exists as well. If not, the mechanism will save
%    \texttt{ulc} in \cs{f@series} which most certainly doesn't
%    exist. So when a font is later selected that would result in a
%    substitution (so no harm done really). Alternatively, we could in
%    this case use \texttt{n} as aternative, which may be a bit
%    faster, but such a  setup would be so weird in the first place
%    that this isn't worth the effort.
%
%    \begin{macrocode}
\DeclareFontShapeChangeRule {scsl}{n}   {sc}     {}
\DeclareFontShapeChangeRule {scsl}{it}  {scit}  {scsl}
\DeclareFontShapeChangeRule {scsl}{sl}  {scsl}  {}
\DeclareFontShapeChangeRule {scsl}{sc}  {scsl}  {}
\DeclareFontShapeChangeRule {scsl}{ulc} {sl}    {}
%    \end{macrocode}


%    By the way, fontspec uses \cs{itscdefault} etc.\ whereas in the
%    \texttt{.fd} files it is always called \texttt{scit}. I
%    personally kind of think ``\texttt{itsc}'' reads better than
%    ``\texttt{scit}'' but with more than 700 fonts (in T1 encoding)
%    having \texttt{scit} and none the other I think the name is now
%    given.
%
%
% \subsection{Changing to a new shape}
%
%  \begin{macro}{\fontshape}
%    Again the \cs{fontshape} now has to do a lookup to get to its new
%    value in \cs{f@shape}. The method is exactly the same as in
%    \csπfontseries}.
%    \begin{macrocode}
\DeclareRobustCommand\fontshape[1]{\merge@font@shape{#1}}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\merge@font@shape}
%    Look up the database entry (if existing) and act accordingly.
%    \begin{macrocode}
\def\merge@font@shape#1{%
  \expandafter\expandafter\expandafter
  \merge@font@shape@
    \csname shape@\f@shape @#1\endcsname
    {#1}%
    \@nil
}  
%    \end{macrocode}
%  \end{macro}
%

%  \begin{macro}{\merge@font@shape@}
%    Same game now, except that we look at shapes not series values.
%    \begin{macrocode}
\def\merge@font@shape@#1#2#3\@nil{%
  \def\@reserveda{#3}%
  \edef\f@shape{%
    \ifx\@reserveda\@empty
      #2%
    \else
      \expandafter \ifx
           \csname \f@encoding /\f@family /\f@series/#1\endcsname
           \relax
         \expandafter \ifx
               \csname \f@encoding /\f@family /\f@series/#2\endcsname
               \relax
           #3%
         \else
           #2%
         \fi
      \else
         #1%
      \fi
    \fi
}}
%    \end{macrocode}
%  \end{macro}




% \section{Supporting nested emphasis}

%    By default \LaTeXe{} supports two levels of nested emphasis: if
%    the current font has an upright shape then it switches to
%    \cs{itshape} otherwise to \cs{eminnershape} (which defaults to
%    \cs{upshape}). This means nested emphasis will ocssilate between
%    italic and upright shapes.
%
%    Sometimes it would be nice to allow for a more lengthly sequence,
%    but instead of providing a fixed one \LaTeX{} now offers a
%    general mechanism that allows to define arbitrary sequences.
%
%    \DeclareMacro\emfontdeclare
%    \DeclareMacro\emforce
%
%    \emph{decide name! maybe \cs{DeclareEmSequence} ???}
%
%    This declaration expects a comma separated list of (font) change
%    declarations corresponding to increasing levels of emphasis.
%    The mechanism tries to be ``smart'' and verifies that the
%    declarations actually alter the font. If not it will ignore this
%    level and tries the next one---the assumption being that
%    there was a manual font change in the document to the font that
%    is now supposed to be used for emphasis. Of course, this only
%    works if the declarations in the list actually change the font
%    and not, say, just the color.
%    In such a case one has to use \cs{emforce} to which directs the
%    mechanism to use the level even if the font attributes haven't changed.
%
%    If the nesting is so deep, that the specified  levels are
%    exhausted then \cs{emreset} is used as a final set of
%    declarations (which by default returns
%    back to the upright shape). ThisAny additional nesting levels will
%    then reuse the list from its beginning. 

%
%
%
%  \begin{macro}{\emfontdeclare}
%    
%    \cs{emfontdeclare| expects a clist of declaration. Spaces in the
%    argument are dropped to avoid surious spaces in the output. The
%    declarations are additive. At the very end the shape is reset
%    using |\emreset| and |\emforce| so that this case is never
%    skipped.\footnote{Maybe we should not add \cs{emforce} but allow
%    that case to be  skipped as well. Of course, that might result in
%    an endless loop if somebody defines a sequence without any font
%    change and without \cs{emforce} but \ldots}
%    Further nested calls restart at the beginning.
%    \begin{macrocode}
\def\emfontdeclare#1{%
  \protected@edef\emfontdeclare@clist{\zap@space#1, \@empty\emforce\emreset}%
}
%    \end{macrocode}
%    By default the ist is empty, in which case \cs{eminnershape} is
%    used by \LaTeX.
%    \begin{macrocode}
\let\emfontdeclare@clist\@empty  
%    \end{macrocode}
%  \end{macro}



%  \begin{macro}{\emreset}
%    Reset the font to upright (this needs to undo \texttt{sc} and
%    \textt{it} separately as \cs{upshape} no longer resets both in
%    one go).
%    \begin{macrocode}
\def\emreset{\fontshape{ulc}% in case sc is in use, e.g,  changes scit -> it
             \fontshape{n}%   for all other cases
}
%    \end{macrocode}
%    We could have used \verb=\fontshape{n}= twice, that would give
%    the same result with the default set of shape rules.
%  \end{macro}



%  \begin{macro}{\em}
%    The new definition for \cs{em} (and implicitly \cs{emph} is like
%    it was before if \cs{emfontdeclare@clist} is empty.
%    \begin{macrocode}
\DeclareRobustCommand\em{%
  \@nomath\em
  \ifx\emfontdeclare@clist\@empty
    \ifdim \fontdimen\@ne\font >\z@
      \eminnershape \else \itshape \fi
  \else
%    \end{macrocode}
%    But if not we use the list to decide how to do emphasis.
%
%    We use the current font to check if the declarations have any
%    effect, so even a size change is allowed and identified as a
%    modification (but a color change, for example, isn't).  So first
%    we save the current status.
%    \begin{macrocode}
  \edef\em@currfont{\csname\curr@fontshape/\f@size\endcsname}%
%    \end{macrocode}
%    Then we grab the next element from the list and check if it can
%    be used.
%    \begin{macrocode}
    \expandafter\do@emfont@update\emfontdeclare@clist\do@emfont@update
  \fi
}
%    \end{macrocode}
%  \end{macro}



%  \begin{macro}{\do@emfont@update}
%    We know that the list (if not empty) has at least 2 elements
%    separated by a comma, so we pick up the first in \texttt{\#1} and
%    the rest in \texttt{\#2}.
%    \begin{macrocode}
\def\do@emfont@update#1,#2\do@emfont@update{%
%    \end{macrocode}
%    First action is to alter the list and move the first entry to the end
%    \begin{macrocode}
  \def\emfontdeclare@clist{#2,#1}%  
%    \end{macrocode}
%    Then we execute current declaration. Appending |\selectfont| means one
%    can write just |\fontshape{it}}| and that works then too.
%    \begin{macrocode}
%  \typeout{Use: \detokenize{#1}}%
  #1\selectfont
%    \end{macrocode}
%    We then compare the current font with our saved version, but with
%    a slight twist: we add \cs{em@force} at the end of the
%    name. Normally this is empty so has no effect but if there was an
%    \cs{emforce} as part of \texttt{\#1} it will append a |/| to the
%    font name (making it invalid) thus this will then always fail the
%    test.
%
%    If the test fails we are done and the declarations will be used.
%    Otherwise we will try the next declaration in the sequence.
%    \begin{macrocode}
  \expandafter\ifx\csname\curr@fontshape/\f@size\em@force\endcsname\em@currfont
  \expandafter\do@emfont@update\emfontdeclare@clist\do@emfont@update
%    \end{macrocode}
%    If \cs{emforce} was used, we have to undo its effect:
%    \begin{macrocode}
  \else
    \let\em@force\@empty
  \fi
}
%    \end{macrocode}
%  \end{macro}



%  \begin{macro}{\emforce}
%  \begin{macro}{\em@force}
%    The definition of \cs{emforce} is simple: change \cs{em@force} to
%    make the above test always invalid.
%    \begin{macrocode}
\protected\def\emforce{\def\em@force{/}}
\let\em@force\@empty
%    \end{macrocode}
%  \end{macro}
%  \end{macro}



