
% \section{Changing the font series}
%
% \emph{write intro}
%
%  \begin{macro}{\DeclareFontSeriesChangeRule}
%    The \cs{DeclareFontSeriesChangeRule} defines entries in a simple
%    database (implemented as a set of commands) that define mappings
%    between from an existing series and requested new series and maps
%    that to  a result series (and additionally offers an alternative
%    if the desired one is not existing):
%    \begin{itemize}
%    \item[\texttt{\#1}] current \cs{f@series}
%    \item[\texttt{\#2}] requested new series
%    \item[\texttt{\#3}] result (if that exist for the given font family
%    \item[\texttt{\#4}] alternative result (if \textt{\#3} does not exist)
%    \end{itemize}
%    If an \texttt{.fd} file has its own substitution rules then
%    \texttt{\#3} exist and thus \textt{\#4} is not applied.
%
%    If there is no matching database entry or if neither the result
%    nor the alternate result exist in the font family the requested
%    new series is used (which then may trigger substitutions later on.
%    \begin{macrocode}
\def\DeclareFontSeriesChangeRule#1#2#3#4{%
  \@namedef{series@#1@#2}{{#3}{#4}}}
%    \end{macrocode}
%  \end{macro}
%
% \subsection{Mapping rules for series changes}
%
% The rules set up use explicit series values not \cs{..default}
% indirections; my current feeling is that this is in fact better.
%
% With 9 weights and 9 width classes this table is getting a bit large
% in the end (324 entries) but on the other hand it doesn't change and
% accessing speed and it is fast this way.
%
% We could alternatively split the axis and maintain weight and width
% separately, but that would take more processing time and would not
% allow for setting up explicit exceptions nicely (not sure that that
% would ever get used though).
%
% \emph{What is missing, is a way to state on document level that one
% wants to revert, say, the weight to ``regular'' but keep the width
% or vize versa. But maybe this is overkill and \cs{bfseries} and
% \cs{mdseries} is all that people need in practice.}
%
% \emph{explain rationale}
%
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {bc}{b}{bc}{}		
\DeclareFontSeriesChangeRule {bc}{c}{bc}{}
\DeclareFontSeriesChangeRule {bc}{eb}{ebc}{}		
\DeclareFontSeriesChangeRule {bc}{el}{elc}{}		
\DeclareFontSeriesChangeRule {bc}{l}{lc}{}		
\DeclareFontSeriesChangeRule {bc}{m}{c}{}
\DeclareFontSeriesChangeRule {bc}{sb}{sbc}{}		
\DeclareFontSeriesChangeRule {bc}{sl}{slc}{}		
\DeclareFontSeriesChangeRule {bc}{ub}{ubc}{}		
\DeclareFontSeriesChangeRule {bc}{ul}{ulc}{}		
\DeclareFontSeriesChangeRule {bc}{x}{bx}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {bx}{bx} {bx}  {b}		%<-----
\DeclareFontSeriesChangeRule {bx}{b}  {b}   {bx}	%<-----
\DeclareFontSeriesChangeRule {bx}{b}{bx}{}		
\DeclareFontSeriesChangeRule {bx}{c}  {bc}  {bx}	%<-----
\DeclareFontSeriesChangeRule {bx}{eb}{ebx}{}		
\DeclareFontSeriesChangeRule {bx}{el}{elx}{}		
\DeclareFontSeriesChangeRule {bx}{l}{lx}{}		
%    \end{macrocode}
%
%    Next rule would be logical, but would just result in many
%    warnings with the default fonts. Without the rule it maps to ``m''.
%    \begin{macrocode}
%\DeclareFontSeriesChangeRule {bx}{m}{x}{}               %<----- mainly
%                                                        % \mdseries
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {bx}{sb} {sbx} {}
\DeclareFontSeriesChangeRule {bx}{sl}{slx}  {}		
\DeclareFontSeriesChangeRule {bx}{ub}{ubx}{}		
\DeclareFontSeriesChangeRule {bx}{ul}{ulx}{}		
\DeclareFontSeriesChangeRule {bx}{x}{bx}{}		
\DeclareFontSeriesChangeRule {bx}{mm}{m}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {b}{bx} {bx}  {b}		%<-----
\DeclareFontSeriesChangeRule {b}{c}  {bc}  {b}		%<-----
\DeclareFontSeriesChangeRule {b}{sb} {sb}  {b}		%<-----
\DeclareFontSeriesChangeRule {b}{x}  {bx}  {b}		%<-----
\DeclareFontSeriesChangeRule {b}{mm}{m}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {c}{bx} {bx}  {b} 		%<-----
\DeclareFontSeriesChangeRule {c}{b}{bc}{}		
\DeclareFontSeriesChangeRule {c}{eb}{ebc}{}		
\DeclareFontSeriesChangeRule {c}{el}{elc}{}		
\DeclareFontSeriesChangeRule {c}{l}{lc}{}		
\DeclareFontSeriesChangeRule {c}{sb}{sbc}{}		
\DeclareFontSeriesChangeRule {c}{sl}{slc}{}		
\DeclareFontSeriesChangeRule {c}{ub}{ubc}{}		
\DeclareFontSeriesChangeRule {c}{ul}{ulc}{}		
\DeclareFontSeriesChangeRule {c}{x}{x}{m}               %<-----
\DeclareFontSeriesChangeRule {c}{mm}{m}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {ebc}{b}{bc}{}		
\DeclareFontSeriesChangeRule {ebc}{c}{ebc}{}		
\DeclareFontSeriesChangeRule {ebc}{eb}{ebc}{}		
\DeclareFontSeriesChangeRule {ebc}{el}{elc}{}		
\DeclareFontSeriesChangeRule {ebc}{l}{lc}{}		
\DeclareFontSeriesChangeRule {ebc}{m}{c}{}		
\DeclareFontSeriesChangeRule {ebc}{sb}{sbc}{}		
\DeclareFontSeriesChangeRule {ebc}{sl}{slc}{}		
\DeclareFontSeriesChangeRule {ebc}{ub}{ubc}{}		
\DeclareFontSeriesChangeRule {ebc}{ul}{ulc}{}		
\DeclareFontSeriesChangeRule {ebc}{x}{ebx}{}		
\DeclareFontSeriesChangeRule {ebc}{mm}{m}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {ebx}{b}{bx}{}		
\DeclareFontSeriesChangeRule {ebx}{c}{ebc}{}		
\DeclareFontSeriesChangeRule {ebx}{eb}{ebx}{}		
\DeclareFontSeriesChangeRule {ebx}{el}{elx}{}		
\DeclareFontSeriesChangeRule {ebx}{l}{lx}{}		
\DeclareFontSeriesChangeRule {ebx}{m}{x}{}		
\DeclareFontSeriesChangeRule {ebx}{sb}{sbx}{}		
\DeclareFontSeriesChangeRule {ebx}{sl}{slx}{}		
\DeclareFontSeriesChangeRule {ebx}{ub}{ubx}{}		
\DeclareFontSeriesChangeRule {ebx}{ul}{ulx}{}		
\DeclareFontSeriesChangeRule {ebx}{x}{ebx}{}		
\DeclareFontSeriesChangeRule {ebx}{mm}{m}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {eb}{c}{ebc}{}		
\DeclareFontSeriesChangeRule {eb}{x}{ebx}{}		
\DeclareFontSeriesChangeRule {eb}{mm}{m}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {elc}{b}{bc}{}		
\DeclareFontSeriesChangeRule {elc}{c}{elc}{}		
\DeclareFontSeriesChangeRule {elc}{eb}{ebc}{}		
\DeclareFontSeriesChangeRule {elc}{el}{elc}{}		
\DeclareFontSeriesChangeRule {elc}{l}{lc}{}		
\DeclareFontSeriesChangeRule {elc}{m}{c}{}		
\DeclareFontSeriesChangeRule {elc}{sb}{sbc}{}		
\DeclareFontSeriesChangeRule {elc}{sl}{slc}{}		
\DeclareFontSeriesChangeRule {elc}{ub}{ubc}{}		
\DeclareFontSeriesChangeRule {elc}{ul}{ulc}{}		
\DeclareFontSeriesChangeRule {elc}{x}{elx}{}		
\DeclareFontSeriesChangeRule {elc}{mm}{m}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {elx}{b}{bx}{}		
\DeclareFontSeriesChangeRule {elx}{c}{elc}{}		
\DeclareFontSeriesChangeRule {elx}{eb}{ebx}{}		
\DeclareFontSeriesChangeRule {elx}{el}{elx}{}		
\DeclareFontSeriesChangeRule {elx}{l}{lx}{}		
\DeclareFontSeriesChangeRule {elx}{m}{x}{}		
\DeclareFontSeriesChangeRule {elx}{sb}{sbx}{}		
\DeclareFontSeriesChangeRule {elx}{sl}{slx}{}		
\DeclareFontSeriesChangeRule {elx}{ub}{ubx}{}		
\DeclareFontSeriesChangeRule {elx}{ul}{ulx}{}		
\DeclareFontSeriesChangeRule {elx}{x}{elx}{}		
\DeclareFontSeriesChangeRule {elx}{mm}{m}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {el}{c}{elc}{}		
\DeclareFontSeriesChangeRule {el}{x}{elx}{}		
\DeclareFontSeriesChangeRule {el}{mm}{m}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {lc}{b}{bc}{}		
\DeclareFontSeriesChangeRule {lc}{c}{lc}{}		
\DeclareFontSeriesChangeRule {lc}{eb}{ebc}{}		
\DeclareFontSeriesChangeRule {lc}{el}{elc}{}		
\DeclareFontSeriesChangeRule {lc}{l}{lc}{}		
\DeclareFontSeriesChangeRule {lc}{m}{c}{}		
\DeclareFontSeriesChangeRule {lc}{sb}{sbc}{}		
\DeclareFontSeriesChangeRule {lc}{sl}{slc}{}		
\DeclareFontSeriesChangeRule {lc}{ub}{ubc}{}		
\DeclareFontSeriesChangeRule {lc}{ul}{ulc}{}		
\DeclareFontSeriesChangeRule {lc}{x}{lx}{}		
\DeclareFontSeriesChangeRule {lc}{mm}{m}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {lx}{b}{bx}{}		
\DeclareFontSeriesChangeRule {lx}{c}{lc}{}		
\DeclareFontSeriesChangeRule {lx}{eb}{ebx}{}		
\DeclareFontSeriesChangeRule {lx}{el}{elx}{}		
\DeclareFontSeriesChangeRule {lx}{l}{lx}{}		
\DeclareFontSeriesChangeRule {lx}{m}{x}{}		
\DeclareFontSeriesChangeRule {lx}{sb}{sbx}{}		
\DeclareFontSeriesChangeRule {lx}{sl}{slx}{}		
\DeclareFontSeriesChangeRule {lx}{ub}{ubx}{}		
\DeclareFontSeriesChangeRule {lx}{ul}{ulx}{}		
\DeclareFontSeriesChangeRule {lx}{x}{lx}{}		
\DeclareFontSeriesChangeRule {lx}{mm}{m}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {l}{bx} {bx}  {b}		%<-----
\DeclareFontSeriesChangeRule {l}{b}  {b}   {bx}		%<-----
\DeclareFontSeriesChangeRule {l}{c}  {lc}  {l}  % ?	%<-----
\DeclareFontSeriesChangeRule {l}{sb} {sb}  {b}  % ?	%<-----
\DeclareFontSeriesChangeRule {l}{x}  {lx}  {l}  % ?	%<-----
\DeclareFontSeriesChangeRule {l}{mm}{m}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {m}{bx} {bx} {b}	  	%<-----
\DeclareFontSeriesChangeRule {m}{b}  {b}  {bx}		%<-----
\DeclareFontSeriesChangeRule {m}{c}  {c}  {m}		%<-----
\DeclareFontSeriesChangeRule {m}{l}  {l}  {m}		%<-----
\DeclareFontSeriesChangeRule {m}{sb} {sb} {b}		%<-----
\DeclareFontSeriesChangeRule {m}{x}  {x}  {m}		%<-----
\DeclareFontSeriesChangeRule {m}{mm}{m}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {sbc}{b}{bc}{}		
\DeclareFontSeriesChangeRule {sbc}{c}{sbc}{}		
\DeclareFontSeriesChangeRule {sbc}{eb}{ebc}{}		
\DeclareFontSeriesChangeRule {sbc}{el}{elc}{}		
\DeclareFontSeriesChangeRule {sbc}{l}{lc}{}		
\DeclareFontSeriesChangeRule {sbc}{m}{c}{}		
\DeclareFontSeriesChangeRule {sbc}{sb}{sbc}{}		
\DeclareFontSeriesChangeRule {sbc}{sl}{slc}{}		
\DeclareFontSeriesChangeRule {sbc}{ub}{ubc}{}		
\DeclareFontSeriesChangeRule {sbc}{ul}{ulc}{}		
\DeclareFontSeriesChangeRule {sbc}{x}{sbx}{}		
\DeclareFontSeriesChangeRule {sbc}{mm}{m}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {sbx}{b}{bx}{}		
\DeclareFontSeriesChangeRule {sbx}{c}{sbc}{}		
\DeclareFontSeriesChangeRule {sbx}{eb}{ebx}{}		
\DeclareFontSeriesChangeRule {sbx}{el}{elx}{}		
\DeclareFontSeriesChangeRule {sbx}{l}{lx}{}		
\DeclareFontSeriesChangeRule {sbx}{m}{x}{}		
\DeclareFontSeriesChangeRule {sbx}{sb}{sbx}{}		
\DeclareFontSeriesChangeRule {sbx}{sl}{slx}{}		
\DeclareFontSeriesChangeRule {sbx}{ub}{ubx}{}		
\DeclareFontSeriesChangeRule {sbx}{ul}{ulx}{}		
\DeclareFontSeriesChangeRule {sbx}{x}{sbx}{}		
\DeclareFontSeriesChangeRule {sbx}{mm}{m}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {sb}{c}  {sbc} {bc} %?	%<-----
\DeclareFontSeriesChangeRule {sb}{x}  {sbx} {bx} %?	%<-----
\DeclareFontSeriesChangeRule {sb}{mm}{m}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {slc}{b}{bc}{}		
\DeclareFontSeriesChangeRule {slc}{c}{slc}{}		
\DeclareFontSeriesChangeRule {slc}{eb}{ebc}{}		
\DeclareFontSeriesChangeRule {slc}{el}{elc}{}		
\DeclareFontSeriesChangeRule {slc}{l}{lc}{}		
\DeclareFontSeriesChangeRule {slc}{m}{c}{}		
\DeclareFontSeriesChangeRule {slc}{sb}{sbc}{}		
\DeclareFontSeriesChangeRule {slc}{sl}{slc}{}		
\DeclareFontSeriesChangeRule {slc}{ub}{ubc}{}		
\DeclareFontSeriesChangeRule {slc}{ul}{ulc}{}		
\DeclareFontSeriesChangeRule {slc}{x}{slx}{}		
\DeclareFontSeriesChangeRule {slc}{mm}{m}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {slx}{b}{bx}{}		
\DeclareFontSeriesChangeRule {slx}{c}{slc}{}		
\DeclareFontSeriesChangeRule {slx}{eb}{ebx}{}		
\DeclareFontSeriesChangeRule {slx}{el}{elx}{}		
\DeclareFontSeriesChangeRule {slx}{l}{lx}{}		
\DeclareFontSeriesChangeRule {slx}{m}{x}{}		
\DeclareFontSeriesChangeRule {slx}{sb}{sbx}{}		
\DeclareFontSeriesChangeRule {slx}{sl}{slx}{}		
\DeclareFontSeriesChangeRule {slx}{ub}{ubx}{}		
\DeclareFontSeriesChangeRule {slx}{ul}{ulx}{}		
\DeclareFontSeriesChangeRule {slx}{x}{slx}{}		
\DeclareFontSeriesChangeRule {sl}{c}{slc}{}		
\DeclareFontSeriesChangeRule {sl}{x}{slx}{}		
\DeclareFontSeriesChangeRule {sl}{mm}{m}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {ubc}{b}{bc}{}		
\DeclareFontSeriesChangeRule {ubc}{c}{ubc}{}		
\DeclareFontSeriesChangeRule {ubc}{eb}{ebc}{}		
\DeclareFontSeriesChangeRule {ubc}{el}{elc}{}		
\DeclareFontSeriesChangeRule {ubc}{l}{lc}{}		
\DeclareFontSeriesChangeRule {ubc}{m}{c}{}		
\DeclareFontSeriesChangeRule {ubc}{sb}{sbc}{}		
\DeclareFontSeriesChangeRule {ubc}{sl}{slc}{}		
\DeclareFontSeriesChangeRule {ubc}{ub}{ubc}{}		
\DeclareFontSeriesChangeRule {ubc}{ul}{ulc}{}		
\DeclareFontSeriesChangeRule {ubc}{x}{ubx}{}		
\DeclareFontSeriesChangeRule {sbc}{mm}{m}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {ubx}{b}{bx}{}		
\DeclareFontSeriesChangeRule {ubx}{c}{ubc}{}		
\DeclareFontSeriesChangeRule {ubx}{eb}{ebx}{}		
\DeclareFontSeriesChangeRule {ubx}{el}{elx}{}		
\DeclareFontSeriesChangeRule {ubx}{l}{lx}{}		
\DeclareFontSeriesChangeRule {ubx}{m}{x}{}		
\DeclareFontSeriesChangeRule {ubx}{sb}{sbx}{}		
\DeclareFontSeriesChangeRule {ubx}{sl}{slx}{}		
\DeclareFontSeriesChangeRule {ubx}{ub}{ubx}{}		
\DeclareFontSeriesChangeRule {ubx}{ul}{ulx}{}		
\DeclareFontSeriesChangeRule {ubx}{x}{ubx}{}		
\DeclareFontSeriesChangeRule {sbx}{mm}{m}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {ub}{c}{ubc}{}		
\DeclareFontSeriesChangeRule {ub}{x}{ubx}{}		
\DeclareFontSeriesChangeRule {ub}{mm}{m}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {ulc}{b}{bc}{}		
\DeclareFontSeriesChangeRule {ulc}{c}{ulc}{}		
\DeclareFontSeriesChangeRule {ulc}{eb}{ebc}{}		
\DeclareFontSeriesChangeRule {ulc}{el}{elc}{}		
\DeclareFontSeriesChangeRule {ulc}{l}{lc}{}		
\DeclareFontSeriesChangeRule {ulc}{m}{c}{}		
\DeclareFontSeriesChangeRule {ulc}{sb}{sbc}{}		
\DeclareFontSeriesChangeRule {ulc}{sl}{slc}{}		
\DeclareFontSeriesChangeRule {ulc}{ub}{ubc}{}		
\DeclareFontSeriesChangeRule {ulc}{ul}{ulc}{}		
\DeclareFontSeriesChangeRule {ulc}{x}{ulx}{}		
\DeclareFontSeriesChangeRule {ulc}{mm}{m}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {ulx}{b}{bx}{}		
\DeclareFontSeriesChangeRule {ulx}{c}{ulc}{}		
\DeclareFontSeriesChangeRule {ulx}{eb}{ebx}{}		
\DeclareFontSeriesChangeRule {ulx}{el}{elx}{}		
\DeclareFontSeriesChangeRule {ulx}{l}{lx}{}		
\DeclareFontSeriesChangeRule {ulx}{m}{x}{}		
\DeclareFontSeriesChangeRule {ulx}{sb}{sbx}{}		
\DeclareFontSeriesChangeRule {ulx}{sl}{slx}{}		
\DeclareFontSeriesChangeRule {ulx}{ub}{ubx}{}		
\DeclareFontSeriesChangeRule {ulx}{ul}{ulx}{}		
\DeclareFontSeriesChangeRule {ulx}{x}{ulx}{}		
\DeclareFontSeriesChangeRule {ul}{c}{ulc}{}		
\DeclareFontSeriesChangeRule {ul}{x}{ulx}{}		
\DeclareFontSeriesChangeRule {ul}{mm}{m}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {x}{b}{bx}{}
\DeclareFontSeriesChangeRule {x}{c}{c}{}
\DeclareFontSeriesChangeRule {x}{eb}{ebx}{}
\DeclareFontSeriesChangeRule {x}{el}{elx}{}
\DeclareFontSeriesChangeRule {x}{l}{lx}{}
\DeclareFontSeriesChangeRule {x}{m}{x}{}	
\DeclareFontSeriesChangeRule {x}{sb}{sbx}{}
\DeclareFontSeriesChangeRule {x}{sl}{slx}{}
\DeclareFontSeriesChangeRule {x}{ub}{ubx}{}
\DeclareFontSeriesChangeRule {x}{ul}{ulx}{}
\DeclareFontSeriesChangeRule {x}{mm}{m}{}		
%    \end{macrocode}
%
% \emph{rules need to get completed!}
%
%

% \subsection{Changing to a new series}
%
%  \begin{macro}{\fontseries}
%    The \cs{fontseries} command takes one argument which is the requested new
%    font series. In the orginal implementation  it simply saved the
%    expanded value in \cs{f@series}. Now we do a bit more processing
%    and look up the final value in the font series data base. This is
%    done by \cs{merge@font@series}.
%    \begin{macrocode}
\DeclareRobustCommand\fontseries[1]{\merge@font@series{#1}}
%    \end{macrocode}
%  \end{macro}


%  \begin{macro}{\merge@font@series}
%    We look up the data base value by expanding the right command
%    twice. If no such value exist then the result will be \cs{relax}
%    otherwise it will be the two brace groups: the desired result and
%    the alternate result. The first case means that the third
%    argument to \cs{merge@font@series} will be empty.
%    \begin{macrocode}
\def\merge@font@series#1{%
  \expandafter\expandafter\expandafter
  \merge@font@series@
    \csname series@\f@series @#1\endcsname
    {#1}%
    \@nil
}  
%    \end{macrocode}
%  \end{macro}


%  \begin{macro}{merge@font@series@}
%    This now defines the new \cs{f@series}:
%    \begin{macrocode}
\def\merge@font@series@#1#2#3\@nil{%
%    \end{macrocode}
%    If the third argument is empty there is no database entry for the
%    combination and the second argument holds the new series so we
%    return that.
%
%    Originally the test was simply \verb=\ifx!#3!= but that actually
%    dies if \texttt{\#3} starts with a conditional and in the
%    definition of \cs{AmSfont} that is actually the case.
%    \begin{macrocode}
  \def\@reserveda{#3}%
  \ifx\@reserveda\@empty
    \edef\f@series{#2}%
  \else
%    \end{macrocode}
%    Otherwise we check if the desired result for the series
%    (\texttt{\#1}) exists for the font family and the current shape.
%    \begin{macrocode}
    \edef\@reserveda{\f@encoding /\f@family /#1/\f@shape}%
     \ifcsname \@reserveda \endcsname
%    \end{macrocode}
%     If the desired result is available then we use that:
%    \begin{macrocode}
       \edef\f@series{#1}%
%    \end{macrocode}
%    If not, then we try the alternate result (\texttt{\#2}).
%    \begin{macrocode}
    \else
       \ifcsname \f@encoding /\f@family /#2/\f@shape \endcsname
%    \end{macrocode}
%    If the alternate result exist we use that
%    \begin{macrocode}
         \edef\f@series{#2}%
         \@font@shape@subst@warning
%    \end{macrocode}
%    If that doesn't exist either, then we use the requested series unmodified.
%    \begin{macrocode}
       \else
         \edef\f@series{#3}%
%    \end{macrocode}
%    We issue a warning that we didn't managed to change to the desired font.
%    \begin{macrocode}
         \@font@shape@subst@warning
       \fi
    \fi
  \fi
}
%    \end{macrocode}
%    It is possible that the previous font and the new one are
%    actually identical (and the font wasn not found because it still
%    needs loading) in which case a warning  would look rather odd. So
%    we make a quick check for that (which is the reason why we defined
%    \cs{@reserveda} above.
%    \begin{macrocode}
\def\@font@shape@subst@warning{%
   \edef\@reservedb{\curr@fontshape}%
   \ifx\@reserveda\@reservedb \else
     \@font@warning{Font shape `\@reserveda' undefined\MessageBreak
                    using `\@reservedb' instead}%
   \fi
}
%    \end{macrocode}
%  \end{macro}




% \section{Changing the  shape}
%
%    Rules for managing shapes (i.e., essentially building in an ``sc''
%    axis).
%
% \emph{write intro}
%
%  \begin{macro}{\DeclareFontShapeChangeRule}
%    The database for shapes is done in exactly the same way, only
%    that it is much smaller and we usually have no alternative shape
%    (or rather it is empty thus not used).
%    \begin{macrocode}
\def\DeclareFontShapeChangeRule #1#2#3#4{%
  \@namedef{shape@#1@#2}{{#3}{#4}}}
%    \end{macrocode}
%  \end{macro}
%
%
%    There is kind of the same problem with returning back from
%    \texttt{sc} to normal. It sort of needs its own letter.  In
%    fontspec this is solved by the first time \cs{upshape} changes
%    \texttt{it} or \texttt{sl} back (so only \texttt{sc} remains) and
%    second time it changes then \texttt{sc} back to normal.  Maybe
%    that's not a bad way to handle it, so I've done that below too.
%    The alternative would be to provide something like \cs{noscshape}
%    as the \pkg{slantsc} package does.
%
%    That sort of approach doesn't seem possible with the series as
%    \cs{bfseries} produces \texttt{bx} (normally) and \cs{mdseries}
%    reverts that back to \texttt{{m} (ie no bold and normal width)
%    and I think that needs to be preserved.
%
%  \begin{macro}{\ulcshape}
%  \begin{macro}{\textulc}
%    To request going back to upper/lowercase we need a new
%    command. It uses \texttt{ulc} as shape name but this shape is
%    virtual, i.e., it doesn't exist as a real shape, it is only used
%    as part of the database table entries and thus only appears in
%    the second argument there (but not in the first).
%    \begin{macrocode}
\DeclareRobustCommand\ulcshape
        {\not@math@alphabet\ulcshape\relax
         \fontshape{ulc}\selectfont}
\DeclareTextFontCommand{\textulc}{\ulcshape}  % back to upper/lower case
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\swshape}
%  \begin{macro}{\textsw}
%  \begin{macro}{\swdefault}
%    New command to select swash shape.
%    \begin{macrocode}
\DeclareRobustCommand\swshape
        {\not@math@alphabet\swshape\relax
         \fontshape\swdefault\selectfont}
\DeclareTextFontCommand{\textsw}{\swshape}
\newcommand\swdefault{sw}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
%
%  \begin{macro}{\sscshape}
%  \begin{macro}{\textssc}
%  \begin{macro}{\sscdefault}
%    New command to select spaced small capitals.
%    \begin{macrocode}
\DeclareRobustCommand\sscshape
        {\not@math@alphabet\sscshape\relax
         \fontshape\sscdefault\selectfont}
\DeclareTextFontCommand{\textssc}{\sscshape}
\newcommand\sscdefault{ssc}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
%
% \subsection{Mapping rules for shape combinations}

%    \begin{macrocode}
\DeclareFontShapeChangeRule {n}{n}   {n}   {}
\DeclareFontShapeChangeRule {n}{it}  {it}  {sl}
\DeclareFontShapeChangeRule {n}{sl}  {sl}  {it}
\DeclareFontShapeChangeRule {n}{sw}  {sw}  {}
\DeclareFontShapeChangeRule {n}{sc}  {sc}  {}
\DeclareFontShapeChangeRule {n}{ulc} {n}   {}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareFontShapeChangeRule {it}{n}   {n}     {}
\DeclareFontShapeChangeRule {it}{it}  {it}    {}
\DeclareFontShapeChangeRule {it}{sl}  {sl}    {it}
\DeclareFontShapeChangeRule {it}{sw}  {sw}    {}
\DeclareFontShapeChangeRule {it}{sc}  {scit}  {scsl}  % or sc or it as second default?
\DeclareFontShapeChangeRule {it}{ulc} {it}    {}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareFontShapeChangeRule {sl}{n}   {n}     {}
\DeclareFontShapeChangeRule {sl}{it}  {it}    {sl}
\DeclareFontShapeChangeRule {sl}{sl}  {sl}    {}
\DeclareFontShapeChangeRule {sl}{sw}  {sw}    {}
\DeclareFontShapeChangeRule {sl}{sc}  {scsl}  {scit}  % sc or sl as second default?
\DeclareFontShapeChangeRule {sl}{ulc} {sl}    {}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareFontShapeChangeRule {sc}{n}   {n}     {}
\DeclareFontShapeChangeRule {sc}{it}  {scit}  {scsl}
\DeclareFontShapeChangeRule {sc}{sl}  {scsl}  {scit}
\DeclareFontShapeChangeRule {sc}{sw}  {scsw}  {sc}      % ????
\DeclareFontShapeChangeRule {sc}{sc}  {sc}    {}
\DeclareFontShapeChangeRule {sc}{ulc} {n}     {}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareFontShapeChangeRule {scit}{n}   {sc}    {}
\DeclareFontShapeChangeRule {scit}{it}  {scit}  {}
\DeclareFontShapeChangeRule {scit}{sl}  {scsl}  {scit}
\DeclareFontShapeChangeRule {scit}{sw}  {scsw}  {sc}    % or scit?  
\DeclareFontShapeChangeRule {scit}{sc}  {scit}  {}
\DeclareFontShapeChangeRule {scit}{ulc} {it}    {}
%    \end{macrocode}
%    The previous rule assumes that if \texttt{scit} exists then
%    \texttt{it} exists as well. If not, the mechanism will save
%    \texttt{ulc} in \cs{f@series} which most certainly doesn't
%    exist. So when a font is later selected that would result in a
%    substitution (so no harm done really). Alternatively, we could in
%    this case use \texttt{n} as aternative, which may be a bit
%    faster, but such a  setup would be so weird in the first place
%    that this isn't worth the effort.
%
%    \begin{macrocode}
\DeclareFontShapeChangeRule {scsl}{n}   {sc}     {}
\DeclareFontShapeChangeRule {scsl}{it}  {scit}  {scsl}
\DeclareFontShapeChangeRule {scsl}{sl}  {scsl}  {}
\DeclareFontShapeChangeRule {scsl}{sw}  {scsw}  {sc}    % or scsl?  
\DeclareFontShapeChangeRule {scsl}{sc}  {scsl}  {}
\DeclareFontShapeChangeRule {scsl}{ulc} {sl}    {}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareFontShapeChangeRule {scsw}{n}   {sc}     {}
\DeclareFontShapeChangeRule {scsw}{it}  {scit}  {scsw}
\DeclareFontShapeChangeRule {scsw}{sl}  {scsl}  {}
\DeclareFontShapeChangeRule {scsw}{sw}  {scsw}  {} 
\DeclareFontShapeChangeRule {scsw}{sc}  {scsw}  {}
\DeclareFontShapeChangeRule {scsw}{ulc} {sw}    {}
%    \end{macrocode}


%    By the way, fontspec uses \cs{itscdefault} etc.\ whereas in the
%    \texttt{.fd} files it is always called \texttt{scit}. I
%    personally kind of think ``\texttt{itsc}'' reads better than
%    ``\texttt{scit}'' but with more than 700 fonts (in T1 encoding)
%    having \texttt{scit} and none the other I think the name is now
%    given.
%
%
% \subsection{Changing to a new shape}
%
%  \begin{macro}{\fontshape}
%    Again the \cs{fontshape} now has to do a lookup to get to its new
%    value in \cs{f@shape}. The method is exactly the same as in
%    \csπfontseries}.
%    \begin{macrocode}
\DeclareRobustCommand\fontshape[1]{\merge@font@shape{#1}}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\merge@font@shape}
%    Look up the database entry (if existing) and act accordingly.
%    \begin{macrocode}
\def\merge@font@shape#1{%
  \expandafter\expandafter\expandafter
  \merge@font@shape@
    \csname shape@\f@shape @#1\endcsname
    {#1}%
    \@nil
}  
%    \end{macrocode}
%  \end{macro}
%

%  \begin{macro}{\merge@font@shape@}
%    Same game now, except that we look at shapes not series values.
%    \begin{macrocode}
\def\merge@font@shape@#1#2#3\@nil{%
  \def\@reserveda{#3}%
  \ifx\@reserveda\@empty
    \edef\f@shape{#2}%
  \else
    \edef\@reserveda{\f@encoding /\f@family /\f@series/#1}%
     \ifcsname \@reserveda\endcsname
       \edef\f@shape{#1}%
    \else
       \ifcsname \f@encoding /\f@family /\f@series/#2\endcsname
         \edef\f@shape{#2}%
         \@font@shape@subst@warning
       \else
         \edef\f@shape{#3}%
         \@font@shape@subst@warning
       \fi
    \fi
  \fi
}
%    \end{macrocode}
%  \end{macro}


%    This code implements one aspect of what the package \pkg{fontaxes}
%    provide. So its redefinitions for the vairous shape commands,
%    such as \cs{itshape} should no longer happen.
%
%    For initial testing we simply undo them at begin document, but of
%    course the correct way would be to update that package to simply
%    use the kernel functionality when running with a new kernel.
%
%    \begin{macrocode}
\AtBeginDocument{%
%    \end{macrocode}
%    I use \cs{protected} here not \cs{DeclareRobustCommand} to avoid
%    extra status lines that would change test results in the test suite.
%    \begin{macrocode}
  \protected\def\upshape
          {\not@math@alphabet\upshape\relax
           \fontshape\updefault\selectfont}%
  \protected\def\slshape
          {\not@math@alphabet\slshape\relax
           \fontshape\sldefault\selectfont}%
  \protected\def\scshape
          {\not@math@alphabet\scshape\relax
           \fontshape\scdefault\selectfont}%
  \protected\def\itshape
          {\not@math@alphabet\itshape\mathit
           \fontshape\itdefault\selectfont}%
  \protected\def\ulcshape
          {\not@math@alphabet\ulcshape\relax
           \fontshape{ulc}\selectfont}%
}
%    \end{macrocode}
%
% The \pkg{fontaxes} package also implements two further shapes,
% namely \cs{swshape} and \cs{sscshape}. They could now easily be
% integrated by specifying a few further table entries such as
%    \begin{macrocode}
%\DeclareFontShapeChangeRule {n}{sw}   {sw}     {n}
%\DeclareFontShapeChangeRule {it}{sw}  {sw}     {it}
%\DeclareFontShapeChangeRule {sc}{sw}  {scsw}   {sc}
%   ...
%    \end{macrocode}
% Again that should happen directly in \pkg{fontaxes} or maybe
% directly in the kernel (even though there are currently only a few fonts
% that support swash letters or ``spaced small capitals'').
%




% \section{Supporting nested emphasis}
%
%    By default \LaTeXe{} supports two levels of nested emphasis: if
%    the current font has an upright shape then it switches to
%    \cs{itshape} otherwise to \cs{eminnershape} (which defaults to
%    \cs{upshape}). This means nested emphasis will ocssilate between
%    italic and upright shapes.
%
%    Sometimes it would be nice to allow for a more lengthly sequence,
%    but instead of providing a fixed one \LaTeX{} now offers a
%    general mechanism that allows to define arbitrary sequences.
%
%    \DeclareMacro\emfontdeclare
%    \DeclareMacro\emforce
%
%    \emph{decide name! maybe \cs{DeclareEmSequence} ???}
%
%    This declaration expects a comma separated list of (font) change
%    declarations corresponding to increasing levels of emphasis.
%    The mechanism tries to be ``smart'' and verifies that the
%    declarations actually alter the font. If not it will ignore this
%    level and tries the next one---the assumption being that
%    there was a manual font change in the document to the font that
%    is now supposed to be used for emphasis. Of course, this only
%    works if the declarations in the list actually change the font
%    and not, say, just the color.
%    In such a case one has to use \cs{emforce} to which directs the
%    mechanism to use the level even if the font attributes haven't changed.
%
%  \DecsribeMacro\emreset
%    If the nesting is so deep, that the specified  levels are
%    exhausted then \cs{emreset} is used as a final set of
%    declarations (which by default returns
%    back to the upright shape). Any additional nesting levels will
%    then reuse the list from its beginning. 

%
%
%
%  \begin{macro}{\emfontdeclare}
%    
%    \cs{emfontdeclare| expects a clist of declaration. Spaces in the
%    argument are dropped to avoid surious spaces in the output. The
%    declarations are additive. At the very end the shape is reset
%    using |\emreset| and |\emforce| so that this case is never
%    skipped.\footnote{Maybe we should not add \cs{emforce} but allow
%    that case to be  skipped as well. Of course, that might result in
%    an endless loop if somebody defines a sequence without any font
%    change and without \cs{emforce} but \ldots}
%    Further nested calls restart at the beginning.
%    \begin{macrocode}
\def\emfontdeclare#1{%
  \protected@edef\emfontdeclare@clist{\zap@space#1, \@empty\emforce\emreset}%
}
%    \end{macrocode}
%    By default the ist is empty, in which case \cs{eminnershape} is
%    used by \LaTeX.
%    \begin{macrocode}
\let\emfontdeclare@clist\@empty  
%    \end{macrocode}
%  \end{macro}



%  \begin{macro}{\emrest}
%    Reset the font to upright (this needs to undo \texttt{sc} and
%    \textt{it} separately as \cs{upshape} no longer resets both in
%    one go).
%    \begin{macrocode}
\DeclareRobustCommand\emreset{%
    \fontshape{ulc}% in case sc is in use, e.g,  changes scit -> it
    \fontshape{n}%   for all other cases
}
%    \end{macrocode}
%    We could have used \verb=\fontshape{n}= twice, that would give
%    the same result with the default set of shape rules.
%  \end{macro}



%  \begin{macro}{\em}
%    The new definition for \cs{em} (and implicitly \cs{emph} is like
%    it was before if \cs{emfontdeclare@clist} is empty.
%    \begin{macrocode}
\DeclareRobustCommand\em{%
  \@nomath\em
  \ifx\emfontdeclare@clist\@empty
    \ifdim \fontdimen\@ne\font >\z@
      \eminnershape \else \itshape \fi
  \else
%    \end{macrocode}
%    But if not we use the list to decide how to do emphasis.
%
%    We use the current font to check if the declarations have any
%    effect, so even a size change is allowed and identified as a
%    modification (but a color change, for example, isn't).  So first
%    we save the current status.
%    \begin{macrocode}
  \edef\em@currfont{\csname\curr@fontshape/\f@size\endcsname}%
%    \end{macrocode}
%    Then we grab the next element from the list and check if it can
%    be used.
%    \begin{macrocode}
    \expandafter\do@emfont@update\emfontdeclare@clist\do@emfont@update
  \fi
}
%    \end{macrocode}
%  \end{macro}



%  \begin{macro}{\do@emfont@update}
%    We know that the list (if not empty) has at least 2 elements
%    separated by a comma, so we pick up the first in \texttt{\#1} and
%    the rest in \texttt{\#2}.
%    \begin{macrocode}
\def\do@emfont@update#1,#2\do@emfont@update{%
%    \end{macrocode}
%    First action is to alter the list and move the first entry to the end
%    \begin{macrocode}
  \def\emfontdeclare@clist{#2,#1}%  
%    \end{macrocode}
%    Then we execute current declaration. Appending |\selectfont| means one
%    can write just |\fontshape{it}}| and that works then too.
%    \begin{macrocode}
%  \typeout{Use: \detokenize{#1}}%
  #1\selectfont
%    \end{macrocode}
%    We then compare the current font with our saved version, but with
%    a slight twist: we add \cs{em@force} at the end of the
%    name. Normally this is empty so has no effect but if there was an
%    \cs{emforce} as part of \texttt{\#1} it will append a |/| to the
%    font name (making it invalid) thus this will then always fail the
%    test.
%
%    If the test fails we are done and the declarations will be used.
%    Otherwise we will try the next declaration in the sequence.
%    \begin{macrocode}
  \expandafter\ifx\csname \curr@fontshape/\f@size\em@force
%    \end{macrocode}
%    For the comparison with \cs{ifx} we have to exand
%    \cs{em@currfont} once as the relevant info is inside.
%    \begin{macrocode}
                          \expandafter\endcsname
                  \em@currfont
  \expandafter\do@emfont@update\emfontdeclare@clist\do@emfont@update
%    \end{macrocode}
%    If \cs{emforce} was used, we have to undo its effect:
%    \begin{macrocode}
  \else
    \let\em@force\@empty
  \fi
}
%    \end{macrocode}
%  \end{macro}



%  \begin{macro}{\emforce}
%  \begin{macro}{\em@force}
%    The definition of \cs{emforce} is simple: change \cs{em@force} to
%    make the above test always invalid.
%    \begin{macrocode}
\protected\def\emforce{\def\em@force{/}}
\let\em@force\@empty
%    \end{macrocode}
%  \end{macro}
%  \end{macro}



% \section{Custom series settings for main document families}
%
%    One problem with the \NFSS{} approach of handling the series axis
%    turned out to be that (especially with respect to ``boldness'')
%    different font families implemented different strategies. For
%    example, with Computer Modern fonts you normally only have
%    \texttt{bx} whereas most PostScript fonts offered only \texttt{b}
%    but not \texttt{bx}. As a result \LaTeX's standard setting for
%    \cs{bfdefault} didn't work with such fonts, but if it got changed
%    to produce \texttt{b}, then that didn't work with Computer Modern
%    if the fonts got combined (e.g., using Computer Modern Typewriter
%    with such fonts).
%
%    The solution back then was to provide substitution rules in the
%    font \textt{.fd} such that if a \texttt{bx} series got requested
%    the \texttt{b} series got used. While this works in that
%    particular case, it isn't a very
%    general solution. For example, if you happen to have a font family that
%    has several weights you may want to typeset  the whole document
%    in a somewhat lighter or darker font but if you then modify
%    \cs{mddefault} to allow for this, then of course your change only
%    works with that particular family but not with the typewriter
%    or sans serif family you also want to use.
%
%    A better solution was provided by the \texttt{mweights} package by
%    Bob Tennent that offers defaults on the level of the three main
%    font families in the document: for ``rm'', ``sf'' and ``tt'' so
%    that font packages could define defaults for the sans serif
%    document font by providing \cs{bfseries@sf} which then was used
%    when \cs{bfseries} got executed and the current family was the
%    \cs{sffamily}.
%
%  \DescribeMacro\DeclareFontSeriesDefault
%    We now support this concept directly from within \LaTeX{} and for
%    use in font packages (or the document preamble) we offer
%    \cs{DeclareSeriesDefault}. This declaration takes three
%    arguments:
%   \begin{description}
%   \item[document family interface:] Can either be \texttt{rm},
%    \texttt{sf} or \texttt{tt}. This is optional and if not given the
%    overall default.
%   \item[document series interface:] Can be \textt{md} or
%    \texttt{bf}.
%   \item[series value:] This is the value that is going to be used
%    with the combination is requested.
%  \end{description}
%
%    For example, \verb=\DeclareFontSeriesDefault[rm]{bf}{sb}= would
%    use \texttt{sb} (semi-bold) when \cs{rmfamily} \cs{bfseries} is
%    asked for.
%
%    If used without the optional argument, e.g.,
%    \verb=\DeclareFontSeriesDefault{bf}{b}=  then this is like
%    redefining \cs{bfdefault} or \cs{mddefault}.
%
%    If some family specify defaults aren't given, e.g. if there are
%    no declarations for, say, \textttt{tt} then the format defaults
%    of \cs{mddefault} and \cs{bfdefault} are assumed. If those are
%    later changed this is \emph{not} reflected!\footnote{I see no
%    easy way to achieve this without compromising compatibility with
%    existing packages that currently use \pkg{mweights} and directly
%    define (some) of the \cs{mdseries@..} commands but not others.}
%
%
%
%  \begin{macro}{\DeclareFontSeriesDefault}
%    The command to declare font series defaults for the ``rm'', ``sf'' or
%    ``tt'' family.
%    \begin{macrocode}
\newcommand\DeclareFontSeriesDefault[3][]{%
  \def\@reserveda{#1}%
%    \end{macrocode}
%    No optional argument: set up general default.
%    \begin{macrocode}
  \ifx\@resereda\@empty
    \ifcsname #2series\endcsname           % supported are
                                           % \[md/bf]default
      \expandafter\def
         \csname #2default\endcsname{#3}%                     
    \else
       \@latex@error{Wrong syntax for \string\DeclareFontSeriesDefault}%
          {Mandatory first argument must be 'md'  or 'bf'.}
    \fi
%    \end{macrocode}
%    Optional argument given, set up specific default.
%    \begin{macrocode}
  \else
    \ifcsname #2series@#1\endcsname          % supported are
                                             % \[md/bf]series@[rm/sf/tt]
      \expandafter\edef
         \csname #2series@#1\endcsname{#3}%                     
    \else
       \@latex@error{Wrong syntax for \string\DeclareFontSeriesDefault}%
          {Optional first argument must be 'rm', 'sf', or 'tt'. \MessageBreak
           Second argument must be 'md'  or 'bf'.}
    \fi
  \fi
}
%    \end{macrocode}
%  \end{macro}




%  \begin{macro}{\mdseries@rm}
%  \begin{macro}{\mdseries@sf}
%  \begin{macro}{\mdseries@tt}
%  \begin{macro}{\bfseries@rm}
%  \begin{macro}{\bfseries@sf}
%  \begin{macro}{\bfseries@tt}
%    We initialize the family specific defaulst at the end of the
%    format generation. Later on they may get overwritten in the
%    preamble or a package via \cs{DeclareFontSeriesDefault} (or
%    possibly directly).
%
%    Conceptual change: The \cs{bfdefault} will be \texttt{b} not
%    \texttt{bx} because that is what it should be really for nearly
%    every font except Computer/Latin Modern.
%
%    To account for the fact that by default we typeset in CM or LM we
%    set up the \cs{bfseries@..} defaults to use \texttt{bx} instead.
%
%    This means that it behaves like before because if the default
%    fonts are used then \cs{bfseries@rm} etc kick in and make
%    \cs{textbf} use \texttt{bx}. However, if the font gets changed
%    then \cs{bfdefault} will get used.
%    \begin{macrocode}
\renewcommand\bfdefault{b}
%    \end{macrocode}
%    
%    \begin{macrocode}
\edef\bfseries@rm{bx}        
\edef\bfseries@sf{bx}
\edef\bfseries@tt{bx}
%    \end{macrocode}
%
%    We also change the default for the medium series to a virtual
%    \texttt{mm}. For this we have rules that it always reset both the
%    weight and the width.
%    \begin{macrocode}
\renewcommand\mddefault{mm}
\edef\mdseries@rm{\mddefault}
\edef\mdseries@sf{\mddefault}
\edef\mdseries@tt{\mddefault}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}



%  \begin{macro}{\expand@font@defaults}
%
%    The family specific defaults are fully expanded, i.e., they are
%    defined via \cs{edef} inside \cs{DeclareFontSeriesDefault}.
%    However, the overall defaults, e.g., \cs{bfdefault} may have been
%    redefined by the user and thus may not be fully expanded. So to
%    enable reliable comparison we make expanded versions of
%    them. That we rerun each time. The alternative would be to only
%    allow for changes before begin document.
%    \begin{macrocode}
\def\expand@font@defaults{%
  \edef\rmdef@ult{\rmdefault}%
  \edef\sfdef@ult{\sfdefault}%
  \edef\ttdef@ult{\ttdefault}%
  \edef\bfdef@ult{\bfdefault}%
  \edef\mddef@ult{\mddefault}%
  \edef\famdef@ult{\familydefault}%
}
%    \end{macrocode}
%
%    \begin{macrocode}
\expand@font@defaults
%    \end{macrocode}
%  \end{macro}



%  \begin{macro}{\bfseries}
%    This document command switches to the bold series.
%    \begin{macrocode}
\DeclareRobustCommand\bfseries{%
  \not@math@alphabet\bfseries\mathbf
%    \end{macrocode}
%    In the original \NFSS{} definition it then called \cs{fontseries}
%    with the value \cs{bfdefault}. In the new scheme we have more
%    alternatives and therefore check if the current family
%    (\cs{f@family}) is the current \cs{rmdef@ult}, \cs{sfdef@ult} or
%    \cs{ttdef@ult}  and the select the correct family default in that case.
%    \begin{macrocode}
  \expand@font@defaults
  \fontseries{%
    \ifx\f@family\rmdef@ult      \bfseries@rm
    \else\ifx\f@family\sfdef@ult \bfseries@sf
    \else\ifx\f@family\ttdef@ult \bfseries@tt
%    \end{macrocode}
%    If not \cs{bfdefault} is used.
%    \begin{macrocode}
    \else                        \bfdefault
    \fi\fi\fi
  }%
  \selectfont
}
%    \end{macrocode}
%  \end{macro}



%  \begin{macro}{\mdseries}
%    This document command switches to the medium series.
%    \begin{macrocode}
\DeclareRobustCommand\mdseries{%
  \not@math@alphabet\mdseries\relax
  \expand@font@defaults
  \fontseries{%
    \ifx\f@family\rmdef@ult      \mdseries@rm
    \else\ifx\f@family\sfdef@ult \mdseries@sf
    \else\ifx\f@family\ttdef@ult \mdseries@tt
    \else                        \mddefault
    \fi\fi\fi
  }%
  \selectfont
}
%    \end{macrocode}
%  \end{macro}


%  \begin{macro}{\rmfamily}
%    Here are the document level commands for changing the main font
%    families.
%    \begin{macrocode}
\DeclareRobustCommand\rmfamily{%
  \not@math@alphabet\rmfamily\mathrm
  % change the current series before changing the family
%    \end{macrocode}
%    If families are changed then we have to do a bit more work.
%    In the original \NFSS implementation
%    a family change kept encoding, series shape and size unchanged
%    but now we can't any 
%    longer simply reuse the current series value. Instead we may have
%    to change it from one family default to the next.
%    \begin{macrocode}
  \expand@font@defaults
%    \end{macrocode}
%    Thus, if the current family is the sans family
%    \begin{macrocode}
  \ifx\f@family\sfdef@ult
%    \end{macrocode}
%    and if we using the medium series of the sans family
%    \begin{macrocode}
       \ifx\f@series\mdseries@sf
%    \end{macrocode}
%    then lets switch to the medium series for the serif family
%    \begin{macrocode}
                                       \fontseries\mdseries@rm
%    \end{macrocode}
%    and if we use the bold series of the sans family switch to the
%    bold default of the serif family:
%    \begin{macrocode}
       \else\ifx\f@series\bfseries@sf  \fontseries\bfseries@rm
%    \end{macrocode}
%    However, the sans family may not have any specific defaults set,
%    so we also compare with the verall defaults.
%    \begin{macrocode}
       \else\ifx\f@series\mddef@ult    \fontseries\mdseries@rm
       \else\ifx\f@series\bfdef@ult    \fontseries\bfseries@rm
%    \end{macrocode}
%    If neither test was true we leave the series alone. This way a
%    special manual setting such as \verb=\fontseries{lc}= is not
%    undone if the family changes (of course there may not be any
%    support for it in the new family but then the \NFSS{}
%    substitution kicks in and  sorts it out).
%    \begin{macrocode}
       \fi\fi\fi\fi
%
%    \end{macrocode}
%    We need to do the same if the current family is the typewriter family:
%    \begin{macrocode}
  \else\ifx\f@family\ttdef@ult
       \ifx\f@series\mdseries@tt       \fontseries\mdseries@rm
       \else\ifx\f@series\bfseries@tt  \fontseries\bfseries@rm
       \else\ifx\f@series\mddef@ult    \fontseries\mdseries@rm
       \else\ifx\f@series\bfdef@ult    \fontseries\bfseries@rm
       \fi\fi\fi\fi
%    \end{macrocode}
%    
%    \begin{macrocode}
  \fi\fi
%    \end{macrocode}
%    With these preparations for series out of the way we can now
%    change the font family to \cs{rmdefault}.
%    \begin{macrocode}
  \fontfamily\rmdefault\selectfont}
%    \end{macrocode}
%    
%  \begin{macro}{\sffamily}
%  \begin{macro}{\ttfamily}
%    The definitions for \cs{sffamily} and \cs{ttfamily} are similar,
%    the differences are only in what font families get checked.
%    \begin{macrocode}
\DeclareRobustCommand\sffamily{%
  \not@math@alphabet\sffamily\mathsf
  \expand@font@defaults
  \ifx\f@family\rmdef@ult
       \ifx\f@series\mdseries@rm       \fontseries\mdseries@sf
       \else\ifx\f@series\bfseries@rm  \fontseries\bfseries@sf
       \else\ifx\f@series\mddef@ult    \fontseries\mdseries@sf
       \else\ifx\f@series\bfdef@ult    \fontseries\bfseries@sf
       \fi\fi\fi\fi
  \else\ifx\f@family\ttdef@ult
       \ifx\f@series\mdseries@tt       \fontseries\mdseries@sf
       \else\ifx\f@series\bfseries@tt  \fontseries\bfseries@sf
       \else\ifx\f@series\mddef@ult    \fontseries\mdseries@sf
       \else\ifx\f@series\bfdef@ult    \fontseries\bfseries@sf
       \fi\fi\fi\fi
  \fi\fi
  \fontfamily\sfdefault\selectfont}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareRobustCommand\ttfamily{%
  \not@math@alphabet\ttfamily\mathtt
  \expand@font@defaults
  \ifx\f@family\rmdef@ult
       \ifx\f@series\mdseries@rm       \fontseries\mdseries@tt
       \else\ifx\f@series\bfseries@rm  \fontseries\bfseries@tt
       \else\ifx\f@series\mddef@ult    \fontseries\mdseries@tt
       \else\ifx\f@series\bfdef@ult    \fontseries\bfseries@tt
       \fi\fi\fi\fi
  \else\ifx\f@family\rmdef@ult
       \ifx\f@series\mdseries@rm       \fontseries\mdseries@tt
       \else\ifx\f@series\bfseries@rm  \fontseries\bfseries@tt
       \else\ifx\f@series\mddef@ult    \fontseries\mdseries@tt
       \else\ifx\f@series\bfdef@ult    \fontseries\bfseries@tt
       \fi\fi\fi\fi
  \fi\fi
  \fontfamily\ttdefault\selectfont}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}








%  \begin{macro}{\AtBeginDocument}
%    
%    If the document preamble has changed the \cs{familydefault} or if
%    the if the \cs{rmdefault} contains a new font family, we have to
%    adjust the series defaults accordingly, before starting
%    typesetting. So we run \cs{rmfamily}, \cs{sffamily} or
%    \cs{ttfamily} depending on the situation which does that (as a
%    sideeffect) for us.
%    \begin{macrocode}
\AtBeginDocument{%
  \expand@font@defaults
%    \end{macrocode}
%    
%    \begin{macrocode}
  \ifx\famdef@ult\rmdef@ult      \rmfamily
  \else\ifx\famdef@ult\sfdef@ult \sffamily
  \else\ifx\famdef@ult\ttdef@ult \ttfamily
  \fi\fi\fi
}%
%    \end{macrocode}
%  \end{macro}



%    As the kernel code now implements the same functionality as
%    \pkg{mweights}, albeit internally coded slightly differently,
%    that package shouldn't be loaded any more.  We therefore pretend
%    that it already got loaded. Thus, a font package that tries to
%    load it and then sets \cs{mdseries@..}, etc.\ will continue to
%    work but will now use the kernel code.
%
%    Of course, mid-term such package should probably use
%    \cs{DeclareFontSeriesDefault} instead of making using low-level
%    definitions.
%
%    \begin{macrocode}
\expandafter\let\csname ver@mweights.sty\endcsname\fmtversion
%    \end{macrocode}



% ^^A Possible issue with tudscr.cls -- needs checking
