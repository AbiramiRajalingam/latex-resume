
% \section{Changing the font series}
%
% \emph{write intro}
%
%  \begin{macro}{\DeclareFontSeriesChangeRule}
%    The \cs{DeclareFontSeriesChangeRule} defines entries in a simple
%    database (implemented as a set of commands) that define mappings
%    between from an existing series and requested new series and maps
%    that to  a result series (and additionally offers an alternative
%    if the desired one is not existing):
%    \begin{itemize}
%    \item[\texttt{\#1}] current \cs{f@series}
%    \item[\texttt{\#2}] requested new series
%    \item[\texttt{\#3}] result (if that exist for the given font family
%    \item[\texttt{\#4}] alternative result (if \texttt{\#3} does not exist)
%    \end{itemize}
%    If an \texttt{.fd} file has its own substitution rules then
%    \texttt{\#3} exist and thus \texttt{\#4} is not applied.
%
%    If there is no matching database entry or if neither the result
%    nor the alternate result exist in the font family the requested
%    new series is used (which then may trigger substitutions later on.
%    \begin{macrocode}
\def\DeclareFontSeriesChangeRule#1#2#3#4{%
  \@namedef{series@#1@#2}{{#3}{#4}}}
%    \end{macrocode}
%  \end{macro}
%
% \subsection{Mapping rules for series changes}
%
% The rules set up use explicit series values not \cs{..default}
% indirections; my current feeling is that this is in fact better.
%
% With 9 weights and 9 width classes this table is getting a bit large
% in the end (324 entries) but on the other hand it doesn't change and
% accessing speed and it is fast this way.
%
% We could alternatively split the axis and maintain weight and width
% separately, but that would take more processing time and would not
% allow for setting up explicit exceptions nicely (not sure that that
% would ever get used though).
%
% Design considerations for mapping entries:
% \begin{itemize}
% \item
%
%    We make \texttt{m} to reset both weight and width (as this is
%    how it always worked). To reset just the width \texttt{?m} is
%    provided and to reset just the weight \texttt{m?}.
%
% \item
%
%   We do support ``\texttt{m}\textit{width}'' and
%    ``\textit{weight}\texttt{m}'', e.g., \texttt{mec} to mean ``go to
%    medium weight and extra-condensed width''. At the end of the
%    process we automatically drop any leftover \texttt{m} in the
%    series name (unless it is just a single \texttt{m}).
%
%
% \item
%
%    If there is no table entry then the target series is used
%    unconditionally. This means that any request to set both weight
%    and width (e.g. \texttt{bx} or \texttt{ulc}) needs no table
%    entries.
%    For that reason there are no entries which have a weight+width as
%    request (i.e., second argument).
%
% \item
%
%    Only a few entries have ``alterative'' values and perhaps most of
%    them should get dropped. Or maybe not \ldots{} needs some thought
%    perhaps.
%
%    The idea is that you don't want the normal substitution to kick
%    in because that would reset the shape first and it may be better
%    to stay with \texttt{b} when a change to \texttt{c} is requested
%    and \texttt{bc} doesn't exist, than to go to first change the
%    shape to \texttt{n} and then find that \texttt{bc/n} doesn't
%    exist either and thus ending up wth \texttt{m/n}.
%
% \item
%
%    Also: while I did set up all nine standard weight values from
%    \texttt{ul} to \texttt{ub} I only bothered to provide entries for
%    \texttt{ec},  \texttt{sc}, \texttt{c} and \texttt{x}, because other levels of
%    compression/expansion are not in any real fonts that I know.
%
%    Could and perhaps should be eventually extended to cover the
%    whole set.
%
% \end{itemize}
%
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {bc}{b}{bc}{}		
\DeclareFontSeriesChangeRule {bc}{c}{bc}{}
\DeclareFontSeriesChangeRule {bc}{eb}{ebc}{}		
\DeclareFontSeriesChangeRule {bc}{ec}{bec} {bc}
\DeclareFontSeriesChangeRule {bc}{el}{elc}{}		
\DeclareFontSeriesChangeRule {bc}{l}{lc}{}		
\DeclareFontSeriesChangeRule {bc}{sb}{sbc}{}		
\DeclareFontSeriesChangeRule {bc}{sc}{bsc} {bc}
\DeclareFontSeriesChangeRule {bc}{sl}{slc}{}		
\DeclareFontSeriesChangeRule {bc}{ub}{ubc}{}		
\DeclareFontSeriesChangeRule {bc}{ul}{ulc}{}		
\DeclareFontSeriesChangeRule {bc}{x}{bx}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {bx}{b}{bx}{}		
\DeclareFontSeriesChangeRule {bx}{c}  {bc}  {bx}	%<-----
\DeclareFontSeriesChangeRule {bx}{eb}{ebx}{}		
\DeclareFontSeriesChangeRule {bx}{ec}  {bec}  {bx}	%<-----
\DeclareFontSeriesChangeRule {bx}{el}{elx}{}		
\DeclareFontSeriesChangeRule {bx}{l}{lx}{}		
\DeclareFontSeriesChangeRule {bx}{sb} {sbx} {}
\DeclareFontSeriesChangeRule {bx}{sc}  {bsc}  {bx}	%<-----
\DeclareFontSeriesChangeRule {bx}{sl}{slx}  {}		
\DeclareFontSeriesChangeRule {bx}{ub}{ubx}{}		
\DeclareFontSeriesChangeRule {bx}{ul}{ulx}{}		
\DeclareFontSeriesChangeRule {bx}{x}{bx}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {b}{bx} {bx}  {b}		%<-----
\DeclareFontSeriesChangeRule {b}{c}  {bc}  {b}		%<-----
\DeclareFontSeriesChangeRule {b}{ec}  {bec}  {b}		%<-----
\DeclareFontSeriesChangeRule {b}{sb} {sb}  {b}		%<-----
\DeclareFontSeriesChangeRule {b}{sc}  {bsc}  {b}		%<-----
\DeclareFontSeriesChangeRule {b}{x}  {bx}  {b}		%<-----
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {c}{bx} {bx}  {b} 		%<-----
\DeclareFontSeriesChangeRule {c}{b}{bc}{}		
\DeclareFontSeriesChangeRule {c}{eb}{ebc}{}		
\DeclareFontSeriesChangeRule {c}{el}{elc}{}		
\DeclareFontSeriesChangeRule {c}{l}{lc}{}		
\DeclareFontSeriesChangeRule {c}{sb}{sbc}{}		
\DeclareFontSeriesChangeRule {c}{sl}{slc}{}		
\DeclareFontSeriesChangeRule {c}{ub}{ubc}{}		
\DeclareFontSeriesChangeRule {c}{ul}{ulc}{}		
\DeclareFontSeriesChangeRule {c}{x}{x}{m}               %<-----
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {ebc}{b}{bc}{}		
\DeclareFontSeriesChangeRule {ebc}{c}{ebc}{}		
\DeclareFontSeriesChangeRule {ebc}{eb}{ebc}{}		
\DeclareFontSeriesChangeRule {ebc}{ec}{ebec}{ebc}		
\DeclareFontSeriesChangeRule {ebc}{el}{elc}{}		
\DeclareFontSeriesChangeRule {ebc}{l}{lc}{}		
\DeclareFontSeriesChangeRule {ebc}{sb}{sbc}{}		
\DeclareFontSeriesChangeRule {ebc}{sc}{ebsc}{ebc}		
\DeclareFontSeriesChangeRule {ebc}{sl}{slc}{}		
\DeclareFontSeriesChangeRule {ebc}{ub}{ubc}{}		
\DeclareFontSeriesChangeRule {ebc}{ul}{ulc}{}		
\DeclareFontSeriesChangeRule {ebc}{x}{ebx}{}		
%    \end{macrocode}
%    
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {ec}{bx} {bx}  {b} 		%<-----
\DeclareFontSeriesChangeRule {ec}{b}{bec}{}		
\DeclareFontSeriesChangeRule {ec}{eb}{ebec}{}		
\DeclareFontSeriesChangeRule {ec}{el}{elec}{}		
\DeclareFontSeriesChangeRule {ec}{l}{lec}{}		
\DeclareFontSeriesChangeRule {ec}{sb}{sbec}{}		
\DeclareFontSeriesChangeRule {ec}{sl}{slec}{}		
\DeclareFontSeriesChangeRule {ec}{ub}{ubec}{}		
\DeclareFontSeriesChangeRule {ec}{ul}{ulec}{}		
\DeclareFontSeriesChangeRule {ec}{x}{x}{m}               %<-----
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {sc}{bx} {bx}  {b} 		%<-----
\DeclareFontSeriesChangeRule {sc}{b}{bsc}{}		
\DeclareFontSeriesChangeRule {sc}{eb}{ebsc}{}		
\DeclareFontSeriesChangeRule {sc}{el}{elsc}{}		
\DeclareFontSeriesChangeRule {sc}{l}{lsc}{}		
\DeclareFontSeriesChangeRule {sc}{sb}{sbsc}{}		
\DeclareFontSeriesChangeRule {sc}{sl}{slsc}{}		
\DeclareFontSeriesChangeRule {sc}{ub}{ubsc}{}		
\DeclareFontSeriesChangeRule {sc}{ul}{ulsc}{}		
\DeclareFontSeriesChangeRule {sc}{x}{x}{m}               %<-----
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {ebx}{b}{bx}{}		
\DeclareFontSeriesChangeRule {ebx}{c}{ebc}{}		
\DeclareFontSeriesChangeRule {ebx}{eb}{ebx}{}		
\DeclareFontSeriesChangeRule {ebx}{ec}{ebec}{}		
\DeclareFontSeriesChangeRule {ebx}{el}{elx}{}		
\DeclareFontSeriesChangeRule {ebx}{l}{lx}{}		
\DeclareFontSeriesChangeRule {ebx}{sb}{sbx}{}		
\DeclareFontSeriesChangeRule {ebx}{sc}{ebsc}{}		
\DeclareFontSeriesChangeRule {ebx}{sl}{slx}{}		
\DeclareFontSeriesChangeRule {ebx}{ub}{ubx}{}		
\DeclareFontSeriesChangeRule {ebx}{ul}{ulx}{}		
\DeclareFontSeriesChangeRule {ebx}{x}{ebx}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {eb}{c}{ebc}{}		
\DeclareFontSeriesChangeRule {eb}{ec}{ebec}{}		
\DeclareFontSeriesChangeRule {eb}{sc}{ebsc}{}		
\DeclareFontSeriesChangeRule {eb}{x}{ebx}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {elc}{b}{bc}{}		
\DeclareFontSeriesChangeRule {elc}{c}{elc}{}		
\DeclareFontSeriesChangeRule {elc}{eb}{ebc}{}		
\DeclareFontSeriesChangeRule {elc}{ec}{elec}{}		
\DeclareFontSeriesChangeRule {elc}{el}{elc}{}		
\DeclareFontSeriesChangeRule {elc}{l}{lc}{}		
\DeclareFontSeriesChangeRule {elc}{sb}{sbc}{}		
\DeclareFontSeriesChangeRule {elc}{sc}{elsc}{}		
\DeclareFontSeriesChangeRule {elc}{sl}{slc}{}		
\DeclareFontSeriesChangeRule {elc}{ub}{ubc}{}		
\DeclareFontSeriesChangeRule {elc}{ul}{ulc}{}		
\DeclareFontSeriesChangeRule {elc}{x}{elx}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {elx}{b}{bx}{}		
\DeclareFontSeriesChangeRule {elx}{c}{elc}{}		
\DeclareFontSeriesChangeRule {elx}{eb}{ebx}{}		
\DeclareFontSeriesChangeRule {elx}{ec}{elec}{}		
\DeclareFontSeriesChangeRule {elx}{el}{elx}{}		
\DeclareFontSeriesChangeRule {elx}{l}{lx}{}		
\DeclareFontSeriesChangeRule {elx}{sb}{sbx}{}		
\DeclareFontSeriesChangeRule {elx}{sc}{elsc}{}		
\DeclareFontSeriesChangeRule {elx}{sl}{slx}{}		
\DeclareFontSeriesChangeRule {elx}{ub}{ubx}{}		
\DeclareFontSeriesChangeRule {elx}{ul}{ulx}{}		
\DeclareFontSeriesChangeRule {elx}{x}{elx}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {el}{c}{elc}{}		
\DeclareFontSeriesChangeRule {el}{ec}{elec}{}		
\DeclareFontSeriesChangeRule {el}{sc}{elsc}{}		
\DeclareFontSeriesChangeRule {el}{x}{elx}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {lc}{b}{bc}{}		
\DeclareFontSeriesChangeRule {lc}{c}{lc}{}		
\DeclareFontSeriesChangeRule {lc}{eb}{ebc}{}		
\DeclareFontSeriesChangeRule {lc}{ec}{lec}{}		
\DeclareFontSeriesChangeRule {lc}{el}{elc}{}		
\DeclareFontSeriesChangeRule {lc}{l}{lc}{}		
\DeclareFontSeriesChangeRule {lc}{sb}{sbc}{}		
\DeclareFontSeriesChangeRule {lc}{sc}{lsc}{}		
\DeclareFontSeriesChangeRule {lc}{sl}{slc}{}		
\DeclareFontSeriesChangeRule {lc}{ub}{ubc}{}		
\DeclareFontSeriesChangeRule {lc}{ul}{ulc}{}		
\DeclareFontSeriesChangeRule {lc}{x}{lx}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {lx}{b}{bx}{}		
\DeclareFontSeriesChangeRule {lx}{c}{lc}{}		
\DeclareFontSeriesChangeRule {lx}{eb}{ebx}{}		
\DeclareFontSeriesChangeRule {lx}{ec}{lec}{}		
\DeclareFontSeriesChangeRule {lx}{el}{elx}{}		
\DeclareFontSeriesChangeRule {lx}{l}{lx}{}		
\DeclareFontSeriesChangeRule {lx}{sb}{sbx}{}		
\DeclareFontSeriesChangeRule {lx}{sc}{lsc}{}		
\DeclareFontSeriesChangeRule {lx}{sl}{slx}{}		
\DeclareFontSeriesChangeRule {lx}{ub}{ubx}{}		
\DeclareFontSeriesChangeRule {lx}{ul}{ulx}{}		
\DeclareFontSeriesChangeRule {lx}{x}{lx}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {l}{bx} {bx}  {b}		%<-----
\DeclareFontSeriesChangeRule {l}{b}  {b}   {bx}		%<-----
\DeclareFontSeriesChangeRule {l}{c}  {lc}  {l}  % ?	%<-----
\DeclareFontSeriesChangeRule {l}{ec}  {lec}  {l}  % ?	%<-----
\DeclareFontSeriesChangeRule {l}{sb} {sb}  {b}  % ?	%<-----
\DeclareFontSeriesChangeRule {l}{sc}  {lsc}  {l}  % ?	%<-----
\DeclareFontSeriesChangeRule {l}{x}  {lx}  {l}  % ?	%<-----
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {m}{bx} {bx} {b}	  	%<----- maybe better ``m''?
\DeclareFontSeriesChangeRule {m}{b}  {b}  {bx}		%<-----
\DeclareFontSeriesChangeRule {m}{c}  {c}  {m}		%<-----
\DeclareFontSeriesChangeRule {m}{ec}  {ec}  {m}		%<-----
\DeclareFontSeriesChangeRule {m}{l}  {l}  {m}		%<-----
\DeclareFontSeriesChangeRule {m}{sb} {sb} {b}		%<-----
\DeclareFontSeriesChangeRule {m}{sc}  {sc}  {m}		%<-----
\DeclareFontSeriesChangeRule {m}{x}  {x}  {m}		%<-----
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {sbc}{b}{bc}{}		
\DeclareFontSeriesChangeRule {sbc}{c}{sbc}{}		
\DeclareFontSeriesChangeRule {sbc}{eb}{ebc}{}		
\DeclareFontSeriesChangeRule {sbc}{ec}{sbec}{sbc}		
\DeclareFontSeriesChangeRule {sbc}{el}{elc}{}		
\DeclareFontSeriesChangeRule {sbc}{l}{lc}{}		
\DeclareFontSeriesChangeRule {sbc}{sb}{sbc}{}		
\DeclareFontSeriesChangeRule {sbc}{sc}{sbsc}{sbc}		
\DeclareFontSeriesChangeRule {sbc}{sl}{slc}{}		
\DeclareFontSeriesChangeRule {sbc}{ub}{ubc}{}		
\DeclareFontSeriesChangeRule {sbc}{ul}{ulc}{}		
\DeclareFontSeriesChangeRule {sbc}{x}{sbx}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {sbx}{b}{bx}{}		
\DeclareFontSeriesChangeRule {sbx}{c}{sbc}{}		
\DeclareFontSeriesChangeRule {sbx}{eb}{ebx}{}		
\DeclareFontSeriesChangeRule {sbx}{ec}{sbec}{}		
\DeclareFontSeriesChangeRule {sbx}{el}{elx}{}		
\DeclareFontSeriesChangeRule {sbx}{l}{lx}{}		
\DeclareFontSeriesChangeRule {sbx}{sb}{sbx}{}		
\DeclareFontSeriesChangeRule {sbx}{sc}{sbsc}{}		
\DeclareFontSeriesChangeRule {sbx}{sl}{slx}{}		
\DeclareFontSeriesChangeRule {sbx}{ub}{ubx}{}		
\DeclareFontSeriesChangeRule {sbx}{ul}{ulx}{}		
\DeclareFontSeriesChangeRule {sbx}{x}{sbx}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {sb}{c}  {sbc} {bc} %?	%<-----
\DeclareFontSeriesChangeRule {sb}{ec}  {sbec} {sbc} %?	%<-----
\DeclareFontSeriesChangeRule {sb}{sc}  {sbsc} {sbc} %?	%<-----
\DeclareFontSeriesChangeRule {sb}{x}  {sbx} {bx} %?	%<-----
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {slc}{b}{bc}{}		
\DeclareFontSeriesChangeRule {slc}{c}{slc}{}		
\DeclareFontSeriesChangeRule {slc}{eb}{ebc}{}		
\DeclareFontSeriesChangeRule {slc}{ec}{slec}{}		
\DeclareFontSeriesChangeRule {slc}{el}{elc}{}		
\DeclareFontSeriesChangeRule {slc}{l}{lc}{}		
\DeclareFontSeriesChangeRule {slc}{sb}{sbc}{}		
\DeclareFontSeriesChangeRule {slc}{sc}{slsc}{}		
\DeclareFontSeriesChangeRule {slc}{sl}{slc}{}		
\DeclareFontSeriesChangeRule {slc}{ub}{ubc}{}		
\DeclareFontSeriesChangeRule {slc}{ul}{ulc}{}		
\DeclareFontSeriesChangeRule {slc}{x}{slx}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {slx}{b}{bx}{}		
\DeclareFontSeriesChangeRule {slx}{c}{slc}{}		
\DeclareFontSeriesChangeRule {slx}{eb}{ebx}{}		
\DeclareFontSeriesChangeRule {slx}{ec}{slec}{}		
\DeclareFontSeriesChangeRule {slx}{el}{elx}{}		
\DeclareFontSeriesChangeRule {slx}{l}{lx}{}		
\DeclareFontSeriesChangeRule {slx}{sb}{sbx}{}		
\DeclareFontSeriesChangeRule {slx}{sc}{slsc}{}		
\DeclareFontSeriesChangeRule {slx}{sl}{slx}{}		
\DeclareFontSeriesChangeRule {slx}{ub}{ubx}{}		
\DeclareFontSeriesChangeRule {slx}{ul}{ulx}{}		
\DeclareFontSeriesChangeRule {slx}{x}{slx}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {sl}{c}{slc}{}		
\DeclareFontSeriesChangeRule {sl}{ec}{slec}{}		
\DeclareFontSeriesChangeRule {sl}{sc}{slsc}{}		
\DeclareFontSeriesChangeRule {sl}{x}{slx}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {ubc}{b}{bc}{}		
\DeclareFontSeriesChangeRule {ubc}{c}{ubc}{}		
\DeclareFontSeriesChangeRule {ubc}{eb}{ebc}{}		
\DeclareFontSeriesChangeRule {ubc}{ec}{ubec}{}		
\DeclareFontSeriesChangeRule {ubc}{el}{elc}{}		
\DeclareFontSeriesChangeRule {ubc}{l}{lc}{}		
\DeclareFontSeriesChangeRule {ubc}{sb}{sbc}{}		
\DeclareFontSeriesChangeRule {ubc}{sc}{ubsc}{}		
\DeclareFontSeriesChangeRule {ubc}{sl}{slc}{}		
\DeclareFontSeriesChangeRule {ubc}{ub}{ubc}{}		
\DeclareFontSeriesChangeRule {ubc}{ul}{ulc}{}		
\DeclareFontSeriesChangeRule {ubc}{x}{ubx}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {ubx}{b}{bx}{}		
\DeclareFontSeriesChangeRule {ubx}{c}{ubc}{}		
\DeclareFontSeriesChangeRule {ubx}{eb}{ebx}{}		
\DeclareFontSeriesChangeRule {ubx}{ec}{ubec}{}		
\DeclareFontSeriesChangeRule {ubx}{el}{elx}{}		
\DeclareFontSeriesChangeRule {ubx}{l}{lx}{}		
\DeclareFontSeriesChangeRule {ubx}{sb}{sbx}{}		
\DeclareFontSeriesChangeRule {ubx}{sc}{ubsc}{}		
\DeclareFontSeriesChangeRule {ubx}{sl}{slx}{}		
\DeclareFontSeriesChangeRule {ubx}{ub}{ubx}{}		
\DeclareFontSeriesChangeRule {ubx}{ul}{ulx}{}		
\DeclareFontSeriesChangeRule {ubx}{x}{ubx}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {ub}{c}{ubc}{}		
\DeclareFontSeriesChangeRule {ub}{ec}{ubec}{}		
\DeclareFontSeriesChangeRule {ub}{sc}{ubsc}{}		
\DeclareFontSeriesChangeRule {ub}{x}{ubx}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {ulc}{b}{bc}{}		
\DeclareFontSeriesChangeRule {ulc}{c}{ulc}{}		
\DeclareFontSeriesChangeRule {ulc}{eb}{ebc}{}		
\DeclareFontSeriesChangeRule {ulc}{ec}{ulec}{ulc}		
\DeclareFontSeriesChangeRule {ulc}{el}{elc}{}		
\DeclareFontSeriesChangeRule {ulc}{l}{lc}{}		
\DeclareFontSeriesChangeRule {ulc}{sb}{sbc}{}		
\DeclareFontSeriesChangeRule {ulc}{sc}{ulsc}{ulc}		
\DeclareFontSeriesChangeRule {ulc}{sl}{slc}{}		
\DeclareFontSeriesChangeRule {ulc}{ub}{ubc}{}		
\DeclareFontSeriesChangeRule {ulc}{ul}{ulc}{}		
\DeclareFontSeriesChangeRule {ulc}{x}{ulx}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {ulx}{b}{bx}{}		
\DeclareFontSeriesChangeRule {ulx}{c}{ulc}{}		
\DeclareFontSeriesChangeRule {ulx}{eb}{ebx}{}		
\DeclareFontSeriesChangeRule {ulx}{ec}{ulec}{}		
\DeclareFontSeriesChangeRule {ulx}{el}{elx}{}		
\DeclareFontSeriesChangeRule {ulx}{l}{lx}{}		
\DeclareFontSeriesChangeRule {ulx}{sb}{sbx}{}		
\DeclareFontSeriesChangeRule {ulx}{sc}{ulsc}{}		
\DeclareFontSeriesChangeRule {ulx}{sl}{slx}{}		
\DeclareFontSeriesChangeRule {ulx}{ub}{ubx}{}		
\DeclareFontSeriesChangeRule {ulx}{ul}{ulx}{}		
\DeclareFontSeriesChangeRule {ulx}{x}{ulx}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {ul}{c}{ulc}{}		
\DeclareFontSeriesChangeRule {ul}{ec}{ulec}{}		
\DeclareFontSeriesChangeRule {ul}{sc}{ulsc}{}		
\DeclareFontSeriesChangeRule {ul}{x}{ulx}{}		
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {x}{b}{bx}{}
\DeclareFontSeriesChangeRule {x}{c}{c}{}
\DeclareFontSeriesChangeRule {x}{eb}{ebx}{}
\DeclareFontSeriesChangeRule {x}{ec}{ec}{}
\DeclareFontSeriesChangeRule {x}{el}{elx}{}
\DeclareFontSeriesChangeRule {x}{l}{lx}{}
\DeclareFontSeriesChangeRule {x}{sb}{sbx}{}
\DeclareFontSeriesChangeRule {x}{sc}{sc}{}
\DeclareFontSeriesChangeRule {x}{sl}{slx}{}
\DeclareFontSeriesChangeRule {x}{ub}{ubx}{}
\DeclareFontSeriesChangeRule {x}{ul}{ulx}{}
%    \end{macrocode}
%
%
%    Special rules for \texttt{lm} etc.\ aren't needed because the
%    target{lm} is used which is reduced to \texttt{l}
%    automatically. Same for \texttt{mc} and friends. Only \texttt{?m}
%    and \texttt{m?} need rules.
%
%    Special rules for \texttt{m?}:
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {bc}{m?}{c}{}
\DeclareFontSeriesChangeRule {bec}{m?}{ec}{}
\DeclareFontSeriesChangeRule {bsc}{m?}{sc}{}
\DeclareFontSeriesChangeRule {bx}{m?}{x}{}		
\DeclareFontSeriesChangeRule {b}{m?}{m}{}		
\DeclareFontSeriesChangeRule {c}{m?}{c}{}		
\DeclareFontSeriesChangeRule {ebc}{m?}{c}{}		
\DeclareFontSeriesChangeRule {ebec}{m?}{ec}{}		
\DeclareFontSeriesChangeRule {ebsc}{m?}{sc}{}		
\DeclareFontSeriesChangeRule {ebx}{m?}{x}{}		
\DeclareFontSeriesChangeRule {eb}{m?}{m}{}		
\DeclareFontSeriesChangeRule {ec}{m?}{ec}{}
\DeclareFontSeriesChangeRule {elc}{m?}{c}{}		
\DeclareFontSeriesChangeRule {elec}{m?}{ec}{}		
\DeclareFontSeriesChangeRule {elsc}{m?}{sc}{}		
\DeclareFontSeriesChangeRule {elx}{m?}{x}{}		
\DeclareFontSeriesChangeRule {el}{m?}{m}{}		
\DeclareFontSeriesChangeRule {lc}{m?}{c}{}		
\DeclareFontSeriesChangeRule {lec}{m?}{ec}{}		
\DeclareFontSeriesChangeRule {lsc}{m?}{sc}{}		
\DeclareFontSeriesChangeRule {lx}{m?}{x}{}		
\DeclareFontSeriesChangeRule {l}{m?}{m}{}		
\DeclareFontSeriesChangeRule {m}{m?}{m}{}		
\DeclareFontSeriesChangeRule {sbc}{m?}{c}{}		
\DeclareFontSeriesChangeRule {sbec}{m?}{ec}{}		
\DeclareFontSeriesChangeRule {sbsc}{m?}{sc}{}		
\DeclareFontSeriesChangeRule {sbx}{m?}{x}{}		
\DeclareFontSeriesChangeRule {sb}{m?}{m}{}		
\DeclareFontSeriesChangeRule {sc}{m?}{sc}{}
\DeclareFontSeriesChangeRule {slc}{m?}{c}{}		
\DeclareFontSeriesChangeRule {slec}{m?}{ec}{}		
\DeclareFontSeriesChangeRule {slsc}{m?}{sc}{}		
\DeclareFontSeriesChangeRule {slx}{m?}{x}{}		
\DeclareFontSeriesChangeRule {sl}{m?}{m}{}		
\DeclareFontSeriesChangeRule {ubc}{m?}{c}{}		
\DeclareFontSeriesChangeRule {ubec}{m?}{ec}{}		
\DeclareFontSeriesChangeRule {ubsc}{m?}{sc}{}		
\DeclareFontSeriesChangeRule {ubx}{m?}{x}{}		
\DeclareFontSeriesChangeRule {ub}{m?}{ub}{}		
\DeclareFontSeriesChangeRule {ulc}{m?}{c}{}		
\DeclareFontSeriesChangeRule {ulec}{m?}{ec}{}
\DeclareFontSeriesChangeRule {ulsc}{m?}{sc}{}
\DeclareFontSeriesChangeRule {ulx}{m?}{x}{}		
\DeclareFontSeriesChangeRule {ul}{m?}{m}{}		
\DeclareFontSeriesChangeRule {x}{m?}{x}{}
%    \end{macrocode}
%
%    Special rules for \texttt{?m}:
%    \begin{macrocode}
\DeclareFontSeriesChangeRule {bc}{?m}{b}{}
\DeclareFontSeriesChangeRule {bec}{?m}{b}{}
\DeclareFontSeriesChangeRule {bsc}{?m}{b}{}
\DeclareFontSeriesChangeRule {bsc}{?m}{b}{}
\DeclareFontSeriesChangeRule {bx}{?m}{b}{}		
\DeclareFontSeriesChangeRule {b}{?m}{b}{}		
\DeclareFontSeriesChangeRule {c}{?m}{m}{}		
\DeclareFontSeriesChangeRule {ebc}{?m}{eb}{}		
\DeclareFontSeriesChangeRule {ebec}{?m}{eb}{}		
\DeclareFontSeriesChangeRule {ebsc}{?m}{eb}{}		
\DeclareFontSeriesChangeRule {ebsc}{?m}{eb}{}		
\DeclareFontSeriesChangeRule {ebx}{?m}{eb}{}		
\DeclareFontSeriesChangeRule {eb}{?m}{eb}{}		
\DeclareFontSeriesChangeRule {ec}{?m}{m}{}		
\DeclareFontSeriesChangeRule {elc}{?m}{el}{}		
\DeclareFontSeriesChangeRule {elec}{?m}{el}{}		
\DeclareFontSeriesChangeRule {elsc}{?m}{el}{}		
\DeclareFontSeriesChangeRule {elsc}{?m}{el}{}		
\DeclareFontSeriesChangeRule {elx}{?m}{el}{}		
\DeclareFontSeriesChangeRule {el}{?m}{el}{}		
\DeclareFontSeriesChangeRule {lc}{?m}{l}{}		
\DeclareFontSeriesChangeRule {lec}{?m}{l}{}		
\DeclareFontSeriesChangeRule {lsc}{?m}{l}{}		
\DeclareFontSeriesChangeRule {lsc}{?m}{l}{}		
\DeclareFontSeriesChangeRule {lx}{?m}{l}{}		
\DeclareFontSeriesChangeRule {l}{?m}{l}{}		
\DeclareFontSeriesChangeRule {m}{?m}{m}{}		
\DeclareFontSeriesChangeRule {sbc}{?m}{sb}{}		
\DeclareFontSeriesChangeRule {sbec}{?m}{sb}{}		
\DeclareFontSeriesChangeRule {sbsc}{?m}{sb}{}		
\DeclareFontSeriesChangeRule {sbsc}{?m}{sb}{}		
\DeclareFontSeriesChangeRule {sbx}{?m}{sb}{}		
\DeclareFontSeriesChangeRule {sb}{?m}{sb}{}		
\DeclareFontSeriesChangeRule {sc}{?m}{m}{}		
\DeclareFontSeriesChangeRule {sc}{?m}{m}{}		
\DeclareFontSeriesChangeRule {slc}{?m}{sl}{}		
\DeclareFontSeriesChangeRule {slec}{?m}{sl}{}		
\DeclareFontSeriesChangeRule {slsc}{?m}{sl}{}		
\DeclareFontSeriesChangeRule {slsc}{?m}{sl}{}		
\DeclareFontSeriesChangeRule {slx}{?m}{sl}{}		
\DeclareFontSeriesChangeRule {sl}{?m}{sl}{}		
\DeclareFontSeriesChangeRule {ubc}{?m}{ub}{}		
\DeclareFontSeriesChangeRule {ubec}{?m}{ub}{}		
\DeclareFontSeriesChangeRule {ubsc}{?m}{ub}{}		
\DeclareFontSeriesChangeRule {ubsc}{?m}{ub}{}		
\DeclareFontSeriesChangeRule {ubx}{?m}{ub}{}		
\DeclareFontSeriesChangeRule {ub}{?m}{m}{}		
\DeclareFontSeriesChangeRule {ulc}{?m}{ul}{}		
\DeclareFontSeriesChangeRule {ulec}{?m}{ul}{}		
\DeclareFontSeriesChangeRule {ulsc}{?m}{ul}{}		
\DeclareFontSeriesChangeRule {ulsc}{?m}{ul}{}		
\DeclareFontSeriesChangeRule {ulx}{?m}{ul}{}		
\DeclareFontSeriesChangeRule {ul}{?m}{ul}{}		
\DeclareFontSeriesChangeRule {x}{?m}{m}{}	
%    \end{macrocode}
%
%    
% \emph{rules need to get completed/verified!}
%
%

% \subsection{Changing to a new series}
%
%  \begin{macro}{\fontseries}
%    The \cs{fontseries} command takes one argument which is the requested new
%    font series. In the orginal implementation  it simply saved the
%    expanded value in \cs{f@series}. Now we do a bit more processing
%    and look up the final value in the font series data base. This is
%    done by \cs{merge@font@series}.
%    \begin{macrocode}
\DeclareRobustCommand\fontseries[1]{\merge@font@series{#1}}
%    \end{macrocode}
%  \end{macro}


%  \begin{macro}{\merge@font@series}
%    We look up the data base value by expanding the right command
%    twice. If no such value exist then the result will be \cs{relax}
%    otherwise it will be the two brace groups: the desired result and
%    the alternate result. The first case means that the third
%    argument to \cs{merge@font@series} will be empty.
%    \begin{macrocode}
\def\merge@font@series#1{%
  \expandafter\expandafter\expandafter
  \merge@font@series@
    \csname series@\f@series @#1\endcsname
    {#1}%
    \@nil
}  
%    \end{macrocode}
%  \end{macro}


%  \begin{macro}{\merge@font@series@}
%    This now defines the new \cs{f@series}:
%    \begin{macrocode}
\def\merge@font@series@#1#2#3\@nil{%
%    \end{macrocode}
%    If the third argument is empty there is no database entry for the
%    combination and the second argument holds the new series so we
%    return that.
%
%    Originally the test was simply \verb=\ifx!#3!= but that actually
%    dies if \texttt{\#3} starts with a conditional and in the
%    definition of \cs{AmSfont} that is actually the case.
%    \begin{macrocode}
  \def\@reserveda{#3}%
  \ifx\@reserveda\@empty
    \set@target@series{#2}%
  \else
%    \end{macrocode}
%    Otherwise we check if the desired result for the series
%    (\texttt{\#1}) exists for the font family and the current shape.
%    \begin{macrocode}
    \edef\@reserveda{\f@encoding /\f@family /#1/\f@shape}%
     \ifcsname \@reserveda \endcsname
%    \end{macrocode}
%     If the desired result is available then we use that:
%    \begin{macrocode}
       \set@target@series{#1}%
%    \end{macrocode}
%    If not, then we try the alternate result (\texttt{\#2}).
%    \begin{macrocode}
    \else
       \ifcsname \f@encoding /\f@family /#2/\f@shape \endcsname
%    \end{macrocode}
%    If the alternate result exist we use that and also issue a
%    warning (or rather a log entry) that we didn't managed to change
%    to the desired font.
%    \begin{macrocode}
         \set@target@series{#2}%
         \@font@shape@subst@warning
%    \end{macrocode}
%    If that doesn't exist either, then we use the requested series unmodified
%    (again with a warning).
%    \begin{macrocode}
       \else
         \set@target@series{#3}%
         \@font@shape@subst@warning
       \fi
    \fi
  \fi
}
%    \end{macrocode}
%    It is possible that the previous font and the new one are
%    actually identical (and the font wasn not found because it still
%    needs loading) in which case a warning  would look rather odd. So
%    we make a quick check for that (which is the reason why we defined
%    \cs{@reserveda} above.
%    \begin{macrocode}
\def\@font@shape@subst@warning{%
   \edef\@reservedb{\curr@fontshape}%
   \ifx\@reserveda\@reservedb \else
     \@font@warning{Font shape `\@reserveda' undefined\MessageBreak
                    using `\@reservedb' instead}%
   \fi
}
%    \end{macrocode}
%  \end{macro}


%  \begin{macro}{\set@target@series}
%  \begin{macro}{\series@drop@one@m}
%    The combined series value determined by the mapping may still
%    contain an \texttt{m} that we have to remove (as the \texttt{.fd}
%    files use \texttt{c} not \texttt{mc} to denote a medium weight
%    condensed series. We do this in all branches above because a user
%    might have written
%\begin{verbatim}
\DeclareFontSeriesChangeRule {m}{sc}{msc}{mc}		
%\end{verbatim}
%    instead of of using \texttt{sc} and \texttt{c} as needed in the
%    \texttt{.fd} file.
%    \begin{macrocode}
\def\set@target@series#1{%
%    \end{macrocode}
%    We need to \cs{edef} the argument first in case it starts with a
%    conditional.
%    \begin{macrocode}
    \edef\f@series{#1}%
    \edef\f@series{\expandafter\series@drop@one@m\f@series mm\series@drop@one@m}%
}
%    \end{macrocode}
%    Drop up to two \texttt{m}s but keep one if that makes the series
%    value empty.
%    \begin{macrocode}
\def\series@drop@one@m#1m#2m#3\series@drop@one@m{%
  \ifx\relax#1#2\relax m\else#1#2\fi
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}


% \section{Changing the  shape}
%
%    Rules for managing shapes (i.e., essentially building in an ``sc''
%    axis).
%
% \emph{write intro}
%
%  \begin{macro}{\DeclareFontShapeChangeRule}
%    The database for shapes is done in exactly the same way, only
%    that it is much smaller and we usually have no alternative shape
%    (or rather it is empty thus not used).
%    \begin{macrocode}
\def\DeclareFontShapeChangeRule #1#2#3#4{%
  \@namedef{shape@#1@#2}{{#3}{#4}}}
%    \end{macrocode}
%  \end{macro}
%
%
%    There is kind of the same problem with returning back from
%    \texttt{sc} to normal. It sort of needs its own letter.  In
%    fontspec this is solved by the first time \cs{upshape} changes
%    \texttt{it} or \texttt{sl} back (so only \texttt{sc} remains) and
%    second time it changes then \texttt{sc} back to normal.  Maybe
%    that's not a bad way to handle it, so I've done that below too.
%    The alternative would be to provide something like \cs{noscshape}
%    as the \textsf{slantsc} package does.
%
%    That sort of approach doesn't seem possible with the series as
%    \cs{bfseries} produces \texttt{bx} (normally) and \cs{mdseries}
%    reverts that back to \texttt{m} (ie no bold and normal width)
%    and I think that needs to be preserved.
%
%  \begin{macro}{\ulcshape}
%  \begin{macro}{\textulc}
%  \begin{macro}{\ulcdefault}
%    To request going back to upper/lowercase we need a new
%    command. It uses \texttt{ulc} as shape name but this shape is
%    virtual, i.e., it doesn't exist as a real shape, it is only used
%    as part of the database table entries and thus only appears in
%    the second argument there (but not in the first).
%    \begin{macrocode}
\DeclareRobustCommand\ulcshape
        {\not@math@alphabet\ulcshape\relax
         \fontshape\ulcdefault\selectfont}
\DeclareTextFontCommand{\textulc}{\ulcshape}  % back to upper/lower case
\newcommand\ulcdefault{ulc}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\swshape}
%  \begin{macro}{\textsw}
%  \begin{macro}{\swdefault}
%    New command to select swash shape.
%    \begin{macrocode}
\DeclareRobustCommand\swshape
        {\not@math@alphabet\swshape\relax
         \fontshape\swdefault\selectfont}
\DeclareTextFontCommand{\textsw}{\swshape}
\newcommand\swdefault{sw}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
%
%  \begin{macro}{\sscshape}
%  \begin{macro}{\textssc}
%  \begin{macro}{\sscdefault}
%    New command to select spaced small capitals.
%    \begin{macrocode}
\DeclareRobustCommand\sscshape
        {\not@math@alphabet\sscshape\relax
         \fontshape\sscdefault\selectfont}
\DeclareTextFontCommand{\textssc}{\sscshape}
\newcommand\sscdefault{ssc}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
%
% \subsection{Mapping rules for shape combinations}
%
%    Many of the entries are commented out as we will get that result
%    without any entry.
%    \begin{macrocode}
%\DeclareFontShapeChangeRule {n}{n}   {n}   {}
\DeclareFontShapeChangeRule {n}{it}  {it}  {sl}
\DeclareFontShapeChangeRule {n}{sl}  {sl}  {it}
%\DeclareFontShapeChangeRule {n}{sw}  {sw}  {}
%\DeclareFontShapeChangeRule {n}{sc}  {sc}  {}
\DeclareFontShapeChangeRule {n}{ulc} {n}   {}
%    \end{macrocode}
%
%    \begin{macrocode}
%\DeclareFontShapeChangeRule {it}{n}   {n}     {}
%\DeclareFontShapeChangeRule {it}{it}  {it}    {}
\DeclareFontShapeChangeRule {it}{sl}  {sl}    {it}
%\DeclareFontShapeChangeRule {it}{sw}  {sw}    {}
%    \end{macrocode}
%    If neither \texttt{scit} nor \texttt{scsl} exist then \texttt{sc}
%    will be used as a fallback albeit with a log entry, so except for
%    the latter there will be no change for CM or Latin Modern fonts.
%    \begin{macrocode}
\DeclareFontShapeChangeRule {it}{sc}  {scit}  {scsl}
\DeclareFontShapeChangeRule {it}{ulc} {it}    {}
%    \end{macrocode}
%
%    \begin{macrocode}
%\DeclareFontShapeChangeRule {sl}{n}   {n}     {}
\DeclareFontShapeChangeRule {sl}{it}  {it}    {sl}
%\DeclareFontShapeChangeRule {sl}{sl}  {sl}    {}
%\DeclareFontShapeChangeRule {sl}{sw}  {sw}    {}
\DeclareFontShapeChangeRule {sl}{sc}  {scsl}  {scit}
\DeclareFontShapeChangeRule {sl}{ulc} {sl}    {}
%    \end{macrocode}
%
%    \begin{macrocode}
%\DeclareFontShapeChangeRule {sc}{n}   {n}     {}
\DeclareFontShapeChangeRule {sc}{it}  {scit}  {scsl}
\DeclareFontShapeChangeRule {sc}{sl}  {scsl}  {scit}
\DeclareFontShapeChangeRule {sc}{sw}  {scsw}  {sw}   
%\DeclareFontShapeChangeRule {sc}{sc}  {sc}    {}
\DeclareFontShapeChangeRule {sc}{ulc} {n}     {}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareFontShapeChangeRule {scit}{n}   {sc}    {}
\DeclareFontShapeChangeRule {scit}{it}  {scit}  {}
\DeclareFontShapeChangeRule {scit}{sl}  {scsl}  {scit}
\DeclareFontShapeChangeRule {scit}{sw}  {scsw}  {sc}    % or scit?  
\DeclareFontShapeChangeRule {scit}{sc}  {scit}  {}
\DeclareFontShapeChangeRule {scit}{ulc} {it}    {}
%    \end{macrocode}
%    The previous rule assumes that if \texttt{scit} exists then
%    \texttt{it} exists as well. If not, the mechanism will save
%    \texttt{ulc} in \cs{f@series} which most certainly doesn't
%    exist. So when a font is later selected that would result in a
%    substitution (so no harm done really). Alternatively, we could in
%    this case use \texttt{n} as aternative, which may be a bit
%    faster, but such a  setup would be so weird in the first place
%    that this isn't worth the effort.
%
%    \begin{macrocode}
\DeclareFontShapeChangeRule {scsl}{n}   {sc}     {}
\DeclareFontShapeChangeRule {scsl}{it}  {scit}  {scsl}
\DeclareFontShapeChangeRule {scsl}{sl}  {scsl}  {}
\DeclareFontShapeChangeRule {scsl}{sw}  {scsw}  {sc}    % or scsl?  
\DeclareFontShapeChangeRule {scsl}{sc}  {scsl}  {}
\DeclareFontShapeChangeRule {scsl}{ulc} {sl}    {}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareFontShapeChangeRule {scsw}{n}   {sc}     {}
\DeclareFontShapeChangeRule {scsw}{it}  {scit}  {scsw}
\DeclareFontShapeChangeRule {scsw}{sl}  {scsl}  {}
\DeclareFontShapeChangeRule {scsw}{sw}  {scsw}  {} 
\DeclareFontShapeChangeRule {scsw}{sc}  {scsw}  {}
\DeclareFontShapeChangeRule {scsw}{ulc} {sw}    {}
%    \end{macrocode}
%
%    \begin{macrocode}
%\DeclareFontShapeChangeRule {sw}{n}   {n}     {}
%\DeclareFontShapeChangeRule {sw}{it}  {it}    {}
%\DeclareFontShapeChangeRule {sw}{sl}  {sl}    {}
%\DeclareFontShapeChangeRule {sw}{sw}  {sw}    {} 
\DeclareFontShapeChangeRule {sw}{sc}  {scsw}  {}
\DeclareFontShapeChangeRule {sw}{ulc} {sw}    {}
%    \end{macrocode}


%    By the way, fontspec uses \cs{itscdefault} etc.\ whereas in the
%    \texttt{.fd} files it is always called \texttt{scit}. I
%    personally kind of think ``\texttt{itsc}'' reads better than
%    ``\texttt{scit}'' but with more than 700 fonts (in T1 encoding)
%    having \texttt{scit} and none the other I think the name is now
%    given.
%
%
% \subsection{Changing to a new shape}
%
%  \begin{macro}{\fontshape}
%    Again the \cs{fontshape} now has to do a lookup to get to its new
%    value in \cs{f@shape}. The method is exactly the same as in
%    \cs{fontseries}.
%    \begin{macrocode}
\DeclareRobustCommand\fontshape[1]{\merge@font@shape{#1}}
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\merge@font@shape}
%    Look up the database entry (if existing) and act accordingly.
%    \begin{macrocode}
\def\merge@font@shape#1{%
  \expandafter\expandafter\expandafter
  \merge@font@shape@
    \csname shape@\f@shape @#1\endcsname
    {#1}%
    \@nil
}  
%    \end{macrocode}
%  \end{macro}
%

%  \begin{macro}{\merge@font@shape@}
%    Same game now, except that we look at shapes not series values.
%    \begin{macrocode}
\def\merge@font@shape@#1#2#3\@nil{%
  \def\@reserveda{#3}%
  \ifx\@reserveda\@empty
    \edef\f@shape{#2}%
  \else
    \edef\@reserveda{\f@encoding /\f@family /\f@series/#1}%
     \ifcsname \@reserveda\endcsname
       \edef\f@shape{#1}%
    \else
       \ifcsname \f@encoding /\f@family /\f@series/#2\endcsname
         \edef\f@shape{#2}%
         \@font@shape@subst@warning
       \else
         \edef\f@shape{#3}%
         \@font@shape@subst@warning
       \fi
    \fi
  \fi
}
%    \end{macrocode}
%  \end{macro}


%    This code implements one aspect of what the package \textsf{fontaxes}
%    provide. So its redefinitions for the vairous shape commands,
%    such as \cs{itshape} should no longer happen.
%
%    For initial testing we simply undo them at begin document, but of
%    course the correct way would be to update that package to simply
%    use the kernel functionality when running with a new kernel.
%
%    \begin{macrocode}
\AtBeginDocument{%
%    \end{macrocode}
%    I use \cs{protected} here not \cs{DeclareRobustCommand} to avoid
%    extra status lines that would change test results in the test suite.
%    \begin{macrocode}
  \protected\def\upshape
          {\not@math@alphabet\upshape\relax
           \fontshape\updefault\selectfont}%
  \protected\def\slshape
          {\not@math@alphabet\slshape\relax
           \fontshape\sldefault\selectfont}%
  \protected\def\scshape
          {\not@math@alphabet\scshape\relax
           \fontshape\scdefault\selectfont}%
  \protected\def\itshape
          {\not@math@alphabet\itshape\mathit
           \fontshape\itdefault\selectfont}%
  \protected\def\ulcshape
          {\not@math@alphabet\ulcshape\relax
           \fontshape{ulc}\selectfont}%
  \protected\def\swshape
          {\not@math@alphabet\swshape\relax
           \fontshape\swdefault\selectfont}%
}
%    \end{macrocode}
%
% The \textsf{fontaxes} package also implements two further shapes,
% namely \cs{swshape} and \cs{sscshape}. They could now easily be
% integrated by specifying a few further table entries such as
%    \begin{macrocode}
%\DeclareFontShapeChangeRule {n}{sw}   {sw}     {n}
%\DeclareFontShapeChangeRule {it}{sw}  {sw}     {it}
%\DeclareFontShapeChangeRule {sc}{sw}  {scsw}   {sc}
%   ...
%    \end{macrocode}
% For \cs{swshape} I have already done that above (even though there are
% currently only a few fonts
% that support swash letters). For  ``spaced small capitals'' there a
% none among the free fonts. Nevertheless, perhaps that should also be integrated
% in the kernel so that the existing \textsf{fontaxes} support continues to
% work in full.
%
%
%
% \subsubsection{Packages that need checking or updating}
%
% These package use \cs{fontprimaryshape}
%\begin{verbatim}
%./baskervaldx/Baskervaldx.sty
%./baskervillef/baskervillef.sty
%./ebgaramond/ebgaramond.sty
%./fontaxes/fontaxes.sty
%\end{verbatim}
%
%
% These package use \cs{fontsecondaryshape}
%\begin{verbatim}
%./baskervaldx/Baskervaldx.sty
%./inriafonts/InriaSans.sty
%./inriafonts/InriaSerif.sty
%./baskervillef/baskervillef.sty
%./ebgaramond/ebgaramond.sty
%./fontaxes/fontaxes.sty
%\end{verbatim}




% \section{Supporting nested emphasis}
%
%    By default \LaTeXe{} supports two levels of nested emphasis: if
%    the current font has an upright shape then it switches to
%    \cs{itshape} otherwise to \cs{eminnershape} (which defaults to
%    \cs{upshape}). This means nested emphasis will ocssilate between
%    italic and upright shapes.
%
%    Sometimes it would be nice to allow for a more lengthly sequence,
%    but instead of providing a fixed one \LaTeX{} now offers a
%    general mechanism that allows to define arbitrary sequences.
%
%    \DescribeMacro\emfontdeclare
%    \DescribeMacro\emforce
%
%    \emph{decide name! maybe \cs{DeclareEmSequence} ???}
%
%    This declaration expects a comma separated list of (font) change
%    declarations corresponding to increasing levels of emphasis.
%    The mechanism tries to be ``smart'' and verifies that the
%    declarations actually alter the font. If not it will ignore this
%    level and tries the next one---the assumption being that
%    there was a manual font change in the document to the font that
%    is now supposed to be used for emphasis. Of course, this only
%    works if the declarations in the list actually change the font
%    and not, say, just the color.
%    In such a case one has to use \cs{emforce} to which directs the
%    mechanism to use the level even if the font attributes haven't changed.
%
%  \DescribeMacro\emreset
%    If the nesting is so deep, that the specified  levels are
%    exhausted then \cs{emreset} is used as a final set of
%    declarations (which by default returns
%    back to the upright shape). Any additional nesting levels will
%    then reuse the list from its beginning. 

%
%
%
%  \begin{macro}{\emfontdeclare}
%    
%    \cs{emfontdeclare} expects a clist of declaration. Spaces in the
%    argument are dropped to avoid surious spaces in the output. The
%    declarations are additive. At the very end the shape is reset
%    using |\emreset| and |\emforce| so that this case is never
%    skipped.\footnote{Maybe we should not add \cs{emforce} but allow
%    that case to be  skipped as well. Of course, that might result in
%    an endless loop if somebody defines a sequence without any font
%    change and without \cs{emforce} but \ldots}
%    Further nested calls restart at the beginning.
%    \begin{macrocode}
\def\emfontdeclare#1{%
  \protected@edef\emfontdeclare@clist{\zap@space#1, \@empty\emforce\emreset}%
}
%    \end{macrocode}
%    By default the it is empty, in which case \cs{eminnershape} is
%    used by \LaTeX.
%    \begin{macrocode}
\let\emfontdeclare@clist\@empty  
%    \end{macrocode}
%  \end{macro}



%  \begin{macro}{\emrest}
%    Reset the font to upright (this needs to undo \texttt{sc} and
%    \texttt{it} separately as \cs{upshape} no longer resets both in
%    one go).
%    \begin{macrocode}
\DeclareRobustCommand\emreset{%
    \fontshape{ulc}% in case sc is in use, e.g,  changes scit -> it
    \fontshape{n}%   for all other cases
}
%    \end{macrocode}
%    We could have used \verb=\fontshape{n}= twice, that would give
%    the same result with the default set of shape rules.
%  \end{macro}



%  \begin{macro}{\em}
%    The new definition for \cs{em} (and implicitly \cs{emph} is like
%    it was before if \cs{emfontdeclare@clist} is empty.
%    \begin{macrocode}
\DeclareRobustCommand\em{%
  \@nomath\em
  \ifx\emfontdeclare@clist\@empty
    \ifdim \fontdimen\@ne\font >\z@
      \eminnershape \else \itshape \fi
  \else
%    \end{macrocode}
%    But if not we use the list to decide how to do emphasis.
%
%    We use the current font to check if the declarations have any
%    effect, so even a size change is allowed and identified as a
%    modification (but a color change, for example, isn't).  So first
%    we save the current status.
%    \begin{macrocode}
  \edef\em@currfont{\csname\curr@fontshape/\f@size\endcsname}%
%    \end{macrocode}
%    Then we grab the next element from the list and check if it can
%    be used.
%    \begin{macrocode}
    \expandafter\do@emfont@update\emfontdeclare@clist\do@emfont@update
  \fi
}
%    \end{macrocode}
%  \end{macro}



%  \begin{macro}{\do@emfont@update}
%    We know that the list (if not empty) has at least 2 elements
%    separated by a comma, so we pick up the first in \texttt{\#1} and
%    the rest in \texttt{\#2}.
%    \begin{macrocode}
\def\do@emfont@update#1,#2\do@emfont@update{%
%    \end{macrocode}
%    First action is to alter the list and move the first entry to the end
%    \begin{macrocode}
  \def\emfontdeclare@clist{#2,#1}%  
%    \end{macrocode}
%    Then we execute current declaration. Appending |\selectfont| means one
%    can write just |\fontshape{it}}| and that works then too.
%    \begin{macrocode}
%  \typeout{Use: \detokenize{#1}}%
  #1\selectfont
%    \end{macrocode}
%    We then compare the current font with our saved version, but with
%    a slight twist: we add \cs{em@force} at the end of the
%    name. Normally this is empty so has no effect but if there was an
%    \cs{emforce} as part of \texttt{\#1} it will append a |/| to the
%    font name (making it invalid) thus this will then always fail the
%    test.
%
%    If the test fails we are done and the declarations will be used.
%    Otherwise we will try the next declaration in the sequence.
%    \begin{macrocode}
  \expandafter\ifx\csname \curr@fontshape/\f@size\em@force
%    \end{macrocode}
%    For the comparison with \cs{ifx} we have to exand
%    \cs{em@currfont} once as the relevant info is inside.
%    \begin{macrocode}
                          \expandafter\endcsname
                  \em@currfont
  \expandafter\do@emfont@update\emfontdeclare@clist\do@emfont@update
%    \end{macrocode}
%    If \cs{emforce} was used, we have to undo its effect:
%    \begin{macrocode}
  \else
    \let\em@force\@empty
  \fi
}
%    \end{macrocode}
%  \end{macro}



%  \begin{macro}{\emforce}
%  \begin{macro}{\em@force}
%    The definition of \cs{emforce} is simple: change \cs{em@force} to
%    make the above test always invalid.
%    \begin{macrocode}
\protected\def\emforce{\def\em@force{/}}
\let\em@force\@empty
%    \end{macrocode}
%  \end{macro}
%  \end{macro}



% \section{Custom series settings for main document families}
%
%    One problem with the NFSS approach of handling the series axis
%    turned out to be that (especially with respect to ``boldness'')
%    different font families implemented different strategies. For
%    example, with Computer Modern fonts you normally only have
%    \texttt{bx} whereas most PostScript fonts offered only \texttt{b}
%    but not \texttt{bx}. As a result \LaTeX's standard setting for
%    \cs{bfdefault} didn't work with such fonts, but if it got changed
%    to produce \texttt{b}, then that didn't work with Computer Modern
%    if the fonts got combined (e.g., using Computer Modern Typewriter
%    with such fonts).
%
%    The solution back then was to provide substitution rules in the
%    font \texttt{.fd} such that if a \texttt{bx} series got requested
%    the \texttt{b} series got used. While this works in that
%    particular case, it isn't a very
%    general solution. For example, if you happen to have a font family that
%    has several weights you may want to typeset  the whole document
%    in a somewhat lighter or darker font but if you then modify
%    \cs{mddefault} to allow for this, then of course your change only
%    works with that particular family but not with the typewriter
%    or sans serif family you also want to use.
%
%    A better solution was provided by the \texttt{mweights} package by
%    Bob Tennent that offers defaults on the level of the three main
%    font families in the document: for ``rm'', ``sf'' and ``tt'' so
%    that font packages could define defaults for the sans serif
%    document font by providing \cs{bfseries@sf} which then was used
%    when \cs{bfseries} got executed and the current family was the
%    \cs{sffamily}.
%
%  \DescribeMacro\DeclareFontSeriesDefault
%    We now support this concept directly from within \LaTeX{} and for
%    use in font packages (or the document preamble) we offer
%    \cs{DeclareSeriesDefault}. This declaration takes three
%    arguments:
%   \begin{description}
%   \item[document family interface:] Can either be \texttt{rm},
%    \texttt{sf} or \texttt{tt}. This is optional and if not given the
%    overall default.
%   \item[document series interface:] Can be \texttt{md} or
%    \texttt{bf}.
%   \item[series value:] This is the value that is going to be used
%    with the combination is requested.
%  \end{description}
%
%    For example, \verb=\DeclareFontSeriesDefault[rm]{bf}{sb}= would
%    use \texttt{sb} (semi-bold) when \cs{rmfamily} \cs{bfseries} is
%    asked for.
%
%    If used without the optional argument, e.g.,
%    \verb=\DeclareFontSeriesDefault{bf}{b}=  then this is like
%    redefining \cs{bfdefault} or \cs{mddefault}.
%
%    If some family specify defaults aren't given, e.g. if there are
%    no declarations for, say, \texttt{tt} then the format defaults
%    of \cs{mddefault} and \cs{bfdefault} are assumed. If those are
%    later changed this is \emph{not} reflected!\footnote{I see no
%    easy way to achieve this without compromising compatibility with
%    existing packages that currently use \textsf{mweights} and directly
%    define (some) of the \cs{mdseries@..} commands but not others.}
%
%
%
%  \begin{macro}{\DeclareFontSeriesDefault}
%    The command to declare font series defaults for the ``rm'', ``sf'' or
%    ``tt'' family.
%    \begin{macrocode}
\newcommand\DeclareFontSeriesDefault[3][]{%
  \def\@reserveda{#1}%
%    \end{macrocode}
%    No optional argument: set up general default.
%    \begin{macrocode}
  \ifx\@resereda\@empty
    \ifcsname #2series\endcsname           % supported are
                                           % \[md/bf]default
      \expandafter\def
         \csname #2default\endcsname{#3}%                     
    \else
       \@latex@error{Wrong syntax for \string\DeclareFontSeriesDefault}%
          {Mandatory first argument must be 'md'  or 'bf'.}
    \fi
%    \end{macrocode}
%    Optional argument given, set up specific default.
%    \begin{macrocode}
  \else
    \ifcsname #2series@#1\endcsname          % supported are
                                             % \[md/bf]series@[rm/sf/tt]
      \expandafter\edef
         \csname #2series@#1\endcsname{#3}%                     
%    \end{macrocode}
%
%    If the interface is used we remove the frozen kernel
%    default. This way, we know that something was explicitly set up
%    (even if the setup has the same value as the default).
%    \begin{macrocode}
      \expandafter\let
         \csname #2series@#1@kernel\endcsname\@undefined
    \else
       \@latex@error{Wrong syntax for \string\DeclareFontSeriesDefault}%
          {Optional first argument must be 'rm', 'sf', or 'tt'. \MessageBreak
           Second argument must be 'md'  or 'bf'.}
    \fi
  \fi
}
%    \end{macrocode}
%  \end{macro}




%  \begin{macro}{\mdseries@rm}
%  \begin{macro}{\mdseries@sf}
%  \begin{macro}{\mdseries@tt}
%  \begin{macro}{\bfseries@rm}
%  \begin{macro}{\bfseries@sf}
%  \begin{macro}{\bfseries@tt}
%    We initialize the family specific default at the end of the
%    format generation. Later on they may get overwritten in the
%    preamble or a package via \cs{DeclareFontSeriesDefault} (or
%    possibly directly).
%
%    Conceptual change: The \cs{bfdefault} will be \texttt{b} not
%    \texttt{bx} because that is what it should be really for nearly
%    every font except Computer/Latin Modern.
%
%    To account for the fact that by default we typeset in CM or LM we
%    set up the \cs{bfseries@..} defaults to use \texttt{bx} instead.
%
%    This means that it behaves like before because if the default
%    fonts are used then \cs{bfseries@rm} etc kick in and make
%    \cs{textbf} use \texttt{bx}. However, if the font gets changed
%    then \cs{bfdefault} will get used.
%    \begin{macrocode}
\renewcommand\bfdefault{b}
%    \end{macrocode}
%    
%    \begin{macrocode}
\def\bfseries@rm{bx}    
\def\bfseries@sf{bx}
\def\bfseries@tt{bx}
%    \end{macrocode}
%
%    Frozen version of the kernel defaults so we can see if they have changed.
%    \begin{macrocode}
\let\bfseries@rm@kernel\bfseries@rm
\let\bfseries@sf@kernel\bfseries@sf
\let\bfseries@tt@kernel\bfseries@tt
%    \end{macrocode}
%
%    The default for the medium series is \texttt{m} and this will be
%    interpreted as resetting both weight and width. To reset only one
%    of them the virtual value \texttt{?m} and \texttt{m?} are available.
%    \begin{macrocode}
\edef\mdseries@rm{\mddefault}
\edef\mdseries@sf{\mddefault}
\edef\mdseries@tt{\mddefault}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}



%  \begin{macro}{\expand@font@defaults}
%
%    The family specific defaults are fully expanded, i.e., they are
%    defined via \cs{edef} inside \cs{DeclareFontSeriesDefault}.
%    However, the overall defaults, e.g., \cs{bfdefault} may have been
%    redefined by the user and thus may not be fully expanded. So to
%    enable reliable comparison we make expanded versions of
%    them. That we rerun each time. The alternative would be to only
%    allow for changes before begin document.
%    \begin{macrocode}
\def\expand@font@defaults{%
  \edef\rmdef@ult{\rmdefault}%
  \edef\sfdef@ult{\sfdefault}%
  \edef\ttdef@ult{\ttdefault}%
  \edef\bfdef@ult{\bfdefault}%
  \edef\mddef@ult{\mddefault}%
  \edef\famdef@ult{\familydefault}%
}
%    \end{macrocode}
%
%    \begin{macrocode}
\expand@font@defaults
%    \end{macrocode}
%  \end{macro}



%  \begin{macro}{\bfseries}
%    This document command switches to the bold series.
%    \begin{macrocode}
\DeclareRobustCommand\bfseries{%
  \not@math@alphabet\bfseries\mathbf
%    \end{macrocode}
%    In the original NFSS definition it then called \cs{fontseries}
%    with the value \cs{bfdefault}. In the new scheme we have more
%    alternatives and therefore check if the current family
%    (\cs{f@family}) is the current \cs{rmdef@ult}, \cs{sfdef@ult} or
%    \cs{ttdef@ult}  and the select the correct family default in that case.
%    \begin{macrocode}
  \expand@font@defaults
  \fontseries{%
    \ifx\f@family\rmdef@ult      \bfseries@rm
    \else\ifx\f@family\sfdef@ult \bfseries@sf
    \else\ifx\f@family\ttdef@ult \bfseries@tt
%    \end{macrocode}
%    If not \cs{bfdefault} is used.
%    \begin{macrocode}
    \else                        \bfdefault
    \fi\fi\fi
  }%
  \selectfont
}
%    \end{macrocode}
%  \end{macro}



%  \begin{macro}{\mdseries}
%    This document command switches to the medium series.
%    \begin{macrocode}
\DeclareRobustCommand\mdseries{%
  \not@math@alphabet\mdseries\relax
  \expand@font@defaults
  \fontseries{%
    \ifx\f@family\rmdef@ult      \mdseries@rm
    \else\ifx\f@family\sfdef@ult \mdseries@sf
    \else\ifx\f@family\ttdef@ult \mdseries@tt
    \else                        \mddefault
    \fi\fi\fi
  }%
  \selectfont
}
%    \end{macrocode}
%  \end{macro}


%  \begin{macro}{\rmfamily}
%    Here are the document level commands for changing the main font
%    families.
%    \begin{macrocode}
\DeclareRobustCommand\rmfamily{%
  \not@math@alphabet\rmfamily\mathrm
  % change the current series before changing the family
%    \end{macrocode}
%    If families are changed then we have to do a bit more work.
%    In the original NFSS implementation
%    a family change kept encoding, series shape and size unchanged
%    but now we can't any 
%    longer simply reuse the current series value. Instead we may have
%    to change it from one family default to the next.
%    \begin{macrocode}
  \expand@font@defaults
%    \end{macrocode}
%    We have to do the testing while while the current family is still
%    unchanged but we have to do the adjustment of the series after it
%    got changed (because the new family might has different sets
%    ofshapes available and we certainly don't want to see
%    substituation going on. So we use \cs{target@series@value} to
%    hold the target series (if any).
%    \begin{macrocode}
  \let\target@series@value\@empty
%    \end{macrocode}
%    Thus, if the current family is the sans family
%    \begin{macrocode}
  \ifx\f@family\sfdef@ult
%    \end{macrocode}
%    and if we using the medium series of the sans family
%    \begin{macrocode}
       \ifx\f@series\mdseries@sf
%    \end{macrocode}
%    then lets switch to the medium series for the serif family
%    \begin{macrocode}
                                       \let\target@series@value\mdseries@rm
%    \end{macrocode}
%    and if we use the bold series of the sans family switch to the
%    bold default of the serif family:
%    \begin{macrocode}
       \else\ifx\f@series\bfseries@sf  \let\target@series@value\bfseries@rm
%    \end{macrocode}
%    However, the sans family may not have any specific defaults set,
%    so we also compare with the verall defaults.
%    \begin{macrocode}
       \else\ifx\f@series\mddef@ult    \let\target@series@value\mdseries@rm
       \else\ifx\f@series\bfdef@ult    \let\target@series@value\bfseries@rm
%    \end{macrocode}
%    If neither test was true we leave the series alone. This way a
%    special manual setting such as \verb=\fontseries{lc}= is not
%    undone if the family changes (of course there may not be any
%    support for it in the new family but then the NFSS
%    substitution kicks in and  sorts it out).
%    \begin{macrocode}
       \fi\fi\fi\fi
%
%    \end{macrocode}
%    We need to do the same if the current family is the typewriter family:
%    \begin{macrocode}
  \else\ifx\f@family\ttdef@ult
       \ifx\f@series\mdseries@tt       \let\target@series@value\mdseries@rm
       \else\ifx\f@series\bfseries@tt  \let\target@series@value\bfseries@rm
       \else\ifx\f@series\mddef@ult    \let\target@series@value\mdseries@rm
       \else\ifx\f@series\bfdef@ult    \let\target@series@value\bfseries@rm
       \fi\fi\fi\fi
%    \end{macrocode}
%    
%    \begin{macrocode}
  \fi\fi
%    \end{macrocode}
%    With these preparations for series out of the way we can now
%    change the font family to \cs{rmdefault}.
%    \begin{macrocode}
  \fontfamily\rmdefault
%    \end{macrocode}
%
%    If \cs{target@series@value} is still empty there is nothing more
%    to do other than selecting the new family. However, if not then
%    we should update the font series now as well. But there is one
%    further subtle issue. We may not have loaded an \texttt{.fd} file
%    for our target font family yet. In the past that was done in
%    \cs{selectfont} if necessary but since we are now doing all the
%    comparisons in \cs{fontseries} we need to make sure that the font
%    family specifications are already loaded prior to calling
%    \cs{fontseries}.
%    \begin{macrocode}
  \ifx\target@series@value\@empty \else
    \begingroup\try@load@fontshape\endgroup
%    \end{macrocode}
%    Updating the series in this case means directly changing
%    \cs{f@series} to the target value. We don't want to go through
%    \cs{fontseries} because that would apply the mappings and then
%    \texttt{bx + b} would keep \texttt{bx} instead of changing to
%    \texttt{b} as desired.
%    as 
%    \begin{macrocode}
    \let\f@series\target@series@value
  \fi
  \selectfont}
%    \end{macrocode}
%    
%  \begin{macro}{\sffamily}
%  \begin{macro}{\ttfamily}
%    The definitions for \cs{sffamily} and \cs{ttfamily} are similar,
%    the differences are only in what font families get checked.
%    \begin{macrocode}
\DeclareRobustCommand\sffamily{%
  \not@math@alphabet\sffamily\mathsf
  \expand@font@defaults
  \let\target@series@value\@empty
  \ifx\f@family\rmdef@ult
       \ifx\f@series\mdseries@rm       \let\target@series@value\mdseries@sf
       \else\ifx\f@series\bfseries@rm  \let\target@series@value\bfseries@sf
       \else\ifx\f@series\mddef@ult    \let\target@series@value\mdseries@sf
       \else\ifx\f@series\bfdef@ult    \let\target@series@value\bfseries@sf
       \fi\fi\fi\fi
  \else\ifx\f@family\ttdef@ult
       \ifx\f@series\mdseries@tt       \let\target@series@value\mdseries@sf
       \else\ifx\f@series\bfseries@tt  \let\target@series@value\bfseries@sf
       \else\ifx\f@series\mddef@ult    \let\target@series@value\mdseries@sf
       \else\ifx\f@series\bfdef@ult    \let\target@series@value\bfseries@sf
       \fi\fi\fi\fi
  \fi\fi
  \fontfamily\sfdefault
  \ifx\target@series@value\@empty \else
    \begingroup\try@load@fontshape\endgroup
    \let\f@series\target@series@value
  \fi
  \selectfont}
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareRobustCommand\ttfamily{%
  \not@math@alphabet\ttfamily\mathtt
  \expand@font@defaults
  \let\target@series@value\@empty
  \ifx\f@family\rmdef@ult
       \ifx\f@series\mdseries@rm       \let\target@series@value\mdseries@tt
       \else\ifx\f@series\bfseries@rm  \let\target@series@value\bfseries@tt
       \else\ifx\f@series\mddef@ult    \let\target@series@value\mdseries@tt
       \else\ifx\f@series\bfdef@ult    \let\target@series@value\bfseries@tt
       \fi\fi\fi\fi
  \else\ifx\f@family\rmdef@ult
       \ifx\f@series\mdseries@rm       \let\target@series@value\mdseries@tt
       \else\ifx\f@series\bfseries@rm  \let\target@series@value\bfseries@tt
       \else\ifx\f@series\mddef@ult    \let\target@series@value\mdseries@tt
       \else\ifx\f@series\bfdef@ult    \let\target@series@value\bfseries@tt
       \fi\fi\fi\fi
  \fi\fi
  \fontfamily\ttdefault
  \ifx\target@series@value\@empty \else
    \begingroup\try@load@fontshape\endgroup
    \let\f@series\target@series@value
  \fi
  \selectfont}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}








%  \begin{macro}{\AtBeginDocument}
%    
%    \begin{macrocode}
\AtBeginDocument{%
%    \end{macrocode}
%
%    We only want \texttt{bx} in \cs{bfseries@rm} if the Roman font is
%    Computer Modern or Latin Modern, otherwise it should be
%    \texttt{b}. It was set to \texttt{bx} in the kernel so that any
%    font use with the default families in the preamble get this
%    value. Now at the real document start we check if the fonts have
%    been changed. If there was a \cs{DeclareFontSeriesDefault}
%    declaration or \cs{bfseries@rm} was directly altered then it
%    differs from \cs{bfseries@rm@kernel} and we do nothing.
%    Otherwise we check if \cs{rmdefault} is one of the CM/LM font
%    families and if so we keep \texttt{bx} otherwise we change it to
%    \texttt{b}.
%
%    This approach doesn't cover one case: CM/LM got changed to a
%    different family that supports \texttt{bx}, but the support
%    package for that family used \verb=\def\bfseries@rm{bx}= instead
%    of using  \cs{DeclareFontSeriesDefault}. In that case the code
%    here changes it to \texttt{b}. Solution: use the
%    \cs{DeclareFontSeriesDefault} interface.
%    \begin{macrocode}
  \ifx\bfseries@rm@kernel\bfseries@rm
    \expandafter\in@\expandafter{\rmdefault}{cmr,cmss,cmtt,lcmss,lcmtt,lmr,lmss,lmtt}%
    \ifin@ \else \def\bfseries@rm{b}\fi\fi
%    \end{macrocode}
%    Same approach for \cs{bfseries@sf} and \cs{bfseries@tt}:
%    \begin{macrocode}
  \ifx\bfseries@sf@kernel\bfseries@sf
    \expandafter\in@\expandafter{\sfdefault}{cmr,cmss,cmtt,lcmss,lcmtt,lmr,lmss,lmtt}%
    \ifin@ \else \def\bfseries@sf{b}\fi\fi
  \ifx\bfseries@tt@kernel\bfseries@tt
    \expandafter\in@\expandafter{\ttdefault}{cmr,cmss,cmtt,lcmss,lcmtt,lmr,lmss,lmtt}%
    \ifin@ \else \def\bfseries@tt{b}\fi\fi
%    \end{macrocode}
%    
%    If the document preamble has changed the \cs{familydefault} or if
%    the if the \cs{rmdefault} contains a new font family, we have to
%    adjust the series defaults accordingly, before starting
%    typesetting. So we run \cs{rmfamily}, \cs{sffamily} or
%    \cs{ttfamily} depending on the situation which does that (as a
%    sideeffect) for us.
%    \begin{macrocode}
  \expand@font@defaults
  \ifx\famdef@ult\rmdef@ult      \rmfamily
  \else\ifx\famdef@ult\sfdef@ult \sffamily
  \else\ifx\famdef@ult\ttdef@ult \ttfamily
  \fi\fi\fi
}%
%    \end{macrocode}
%  \end{macro}



%    As the kernel code now implements the same functionality as
%    \textsf{mweights}, albeit internally coded slightly differently,
%    that package shouldn't be loaded any more.  We therefore pretend
%    that it already got loaded. Thus, a font package that tries to
%    load it and then sets \cs{mdseries@..}, etc.\ will continue to
%    work but will now use the kernel code.
%
%    Of course, mid-term such package should probably use
%    \cs{DeclareFontSeriesDefault} instead of making using low-level
%    definitions.
%
%    \begin{macrocode}
\expandafter\let\csname ver@mweights.sty\endcsname\fmtversion
%    \end{macrocode}



% ^^A Possible issue with tudscr.cls -- needs checking
