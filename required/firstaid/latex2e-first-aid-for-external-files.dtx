% \iffalse meta-comment
%
%% File: latex2e-first-aid-for-external-files.dtx (C) Copyright 2020 
%% The LaTeX Project and any individual authors listed elsewhere
%% in this file.
%
% It may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3c
% of this license or (at your option) any later version.
% The latest version of this license is in
%    https://www.latex-project.org/lppl.txt
% and version 1.3c or later is part of all distributions of LaTeX
% version 2008 or later.
%
% This file has the LPPL maintenance status "maintained".
%
%
%
%<*driver>
\documentclass{ltxdoc}
\EnableCrossrefs
\CodelineIndex
\begin{document}
  \DocInput{latex2e-first-aid-for-external-files.dtx}
\end{document}
%</driver>
%
% \fi
%
%
% \providecommand\pkg[1]{\texttt{#1}}
%
% \title{First aid for external files and packages that need updating\thanks{}}
% \author{Frank Mittelbach, \LaTeX{} Project}
%
% \maketitle
%
%
% \begin{abstract}
%    This file contains some first aid for packages or classes that
%    require updates because of internal changes to \LaTeX{} but that
%    aren't yet reflected in the package/class code.
% \end{abstract}
%
% \tableofcontents
%
% \section{Introduction}
%
%    Over the years package writers have hooked into
%    various parts of internal \LaTeX{} commands (largely because
%    proper interfaces were missing in important places) and if
%    we are now gradually adding such interfaces these internal
%    commands do change and as a result patching into them stops
%    working.
%
%    As part of making such internal changes the \LaTeX{} Project team
%    attempts to check for such usage in packages, alert the package
%    maintainers and ensures that the packages get updated alongside
%    the core \LaTeX{} system. However it is not always possible to
%    get packages that will fail with a new kernel updated in time and
%    if that is the case we try to provide a temporary fix in this
%    file for them.
%    Once the package gets updated the fix will then be removed again.
%
%    For that reason, it is put into a separate bundle so that we can
%    update it easily without requiring the CTAN maintainers to
%    install a new full LaTeX system just because we take out (or add)
%    a fix for a package here.
%
%    In the best case scenario the file documented here should be
%    empty. In practice it will probably always contain one or the
%    other fix while we are waiting for the package to get updated.
%
%    \begin{quote} \textbf{Important notice:} The fixes provided here
%    are not meant to be a permanent solution, but are only provided
%    to support the transition period. They are (usually) neither
%    complete nor necessarily the best solution! Furthermore, as they
%    are done from the ``outside'', they usually add some burden and
%    slow down \LaTeX{} processing, even if the package/class is not
%    used in the document.
%
%    We will therefore remove such code as soon as possible
%    again. In practice this means that if some package never gets
%    updated/corrected, then it will eventually fail to work, because
%    after one or at most two \LaTeX{} releases we will take out the
%    transition code to ensure that this ``first aid patching''
%    doesn't get out of bounds.
%    \end{quote}
%
% \StopEventually{\setlength\IndexMin{200pt}  \PrintIndex  }
%
%
% \section{The Implementation}
%
%    This file is meant to be loaded during format generation which is
%    why we give it the extension \texttt{.ltx}.
%    \begin{macrocode}
%<*kernel>
%    \end{macrocode}
%
%    \begin{macrocode}
\def\LaTeXFirstAidDate{2020/09/28}
\def\LaTeXFirstAidVersion{v1.0b}
%    \end{macrocode}
%
%    \begin{macrocode}
\ProvidesFile{latex2e-first-aid-for-external-files.ltx}
             [\LaTeXFirstAidDate\space \LaTeXFirstAidVersion\space
               LaTeX kernel fixes to external files and packages]
%    \end{macrocode}
%
% \subsection{Package version peeking}
%
%    \begin{macrocode}
%<@@=firstaid>
\ExplSyntaxOn
%    \end{macrocode}
%
% \begin{macro}{\l_@@_line_tl}
% \begin{macro}{\g_@@_pkg_ior}
% \begin{macro}{\l_@@_needs_bool}
%   Some variables needed.
%    \begin{macrocode}
\tl_new:N \l_@@_line_tl
\tl_new:N \l_@@_stored_tl
\tl_new:N \l_@@_target_tl
\ior_new:N \g_@@_pkg_ior
\bool_new:N \l_@@_needs_bool
\scan_new:N \s_@@
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[TF]{\firstaid_if_needed:nn}
%   \cs{firstaid_if_needed:nn} will check if version |#2| of package
%   |#1| requires first-aid treatment (that is, if the version installed
%   matches |#2|).  It returns \meta{true} or \meta{false}, accordingly.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \firstaid_if_needed:nn #1 #2
    { T, F, TF }
  {
    \cs_if_exist:cTF { ver@#1.sty }
      {
%    \end{macrocode}
%
%   If the file is already loaded, check if the loaded version matches,
%   and return \meta{true} or \meta{false}.
%    \begin{macrocode}
        \str_if_eq:eeTF { \use:c { ver@#1.sty } } {#2}
          { \prg_return_true: }
          { \prg_return_false: }
      }
      {
%    \end{macrocode}
%
%   If the package is not read yet (\cs[no-index]{ver@\#1} is not
%   defined), then we will silently open the file and peek through its
%   contents with \cs{@@_peek_file:}.
%    \begin{macrocode}
        \tl_set:Nn \l_@@_target_tl { {#1}[#2] }
        \tl_clear:N \l_@@_stored_tl
        \ior_open:Nn \g_@@_pkg_ior { #1.sty }
        \@@_peek_file:
        \ior_close:N \g_@@_pkg_ior
        \bool_if:NTF \l_@@_needs_bool
          { \prg_return_true: }
          { \prg_return_false: }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_peek_file:}
%   If the file isn't loaded yet, we'll read it looking for
%   \cs{ProvidesPackage} and read the argument to that and then check
%   the available version.  There are a few limitations of when this
%   will work:  the \cs{ProvidesPackage} cannot be within braces, and it
%   must be the first occurrence of the control sequence in the file.
%
%   The file is read line by line, looking for \cs{ProvidesPackage}.
%   If the end of the file is reached, the boolean \cs{l_@@_needs_bool}
%   is set to false (a package without a \cs{ProvidesPackage} line is
%   set to \emph{not} need first-aid;  this could be changed if needed).
%    \begin{macrocode}
\cs_new_protected:Npn \@@_peek_file:
  {
    \ior_get:NNTF \g_@@_pkg_ior \l_@@_line_tl
      {
        \tl_if_in:NnTF \l_@@_line_tl { \ProvidesPackage }
          { \exp_after:wN \@@_scan_provides_args:w \l_@@_line_tl \s_@@ }
          { \@@_peek_file: }
      }
      { \bool_set_false:N \l_@@_needs_bool }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%     \@@_scan_provides_args:w,
%     \@@_scan_provides_marg:,
%     \@@_marg_check:n,
%     \@@_put_provides_marg:w,
%   }
%   Now extract the tokens after \cs{ProvidesPackage}, and look for the
%   mandatory argument;  the package name.  Once done, call
%   \cs{@@_put_provides_marg:w} to put the mandatory argument into the
%   storage token list and call \cs{@@_start_opt_check:n} to look for
%   the optional argument.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_scan_provides_args:w
    #1 \ProvidesPackage #2 \s_@@
  { \@@_marg_check:n {#2} }
\cs_new_protected:Npn \@@_scan_provides_marg:
  {
    \ior_get:NNTF \g_@@_pkg_ior \l_@@_line_tl
      { \exp_args:NV \@@_marg_check:n \l_@@_line_tl }
      { \bool_set_false:N \l_@@_needs_bool }
  }
\cs_new_protected:Npn \@@_marg_check:n #1
  {
    \tl_if_blank:nTF {#1}
      { \@@_scan_provides_marg: }
      { \@@_put_provides_marg:w #1 \s_@@ }
  }
\cs_new_protected:Npn \@@_put_provides_marg:w #1 #2 \s_@@
  {
    \tl_put_right:Nn \l_@@_stored_tl { {#1} }
    \@@_start_opt_check:n {#2}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%     \@@_start_opt_check:n,
%     \@@_start_provides_opt:,
%     \@@_end_opt_check:n,
%     \@@_scan_provides_opt:,
%     \@@_empty_provides_opt:,
%   }
%   Look for the optional argument by checking that the first non-blank
%   token is a |[|, then grabbing lines one by one looking for an
%   unbraced |]| which ends the optional argument.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_start_opt_check:n #1
  {
    \tl_if_blank:nTF {#1}
      { \@@_start_provides_opt: }
      {
        \str_if_eq:eeTF { \use_i_delimit_by_q_nil:nw #1 \q_nil } { [ }
          { \@@_end_opt_check:n {#1} }
          { \@@_empty_provides_opt: }
      }
  }
\cs_new_protected:Npn \@@_start_provides_opt:
  {
    \ior_get:NNTF \g_@@_pkg_ior \l_@@_line_tl
      { \exp_args:NV \@@_start_opt_check:n \l_@@_line_tl }
      { \@@_empty_provides_opt: }
  }
\cs_new_protected:Npn \@@_scan_provides_opt:
  {
    \ior_get:NNTF \g_@@_pkg_ior \l_@@_line_tl
      { \exp_args:NV \@@_end_opt_check:n \l_@@_line_tl }
      { \bool_set_false:N \l_@@_needs_bool }
  }
\cs_new_protected:Npn \@@_end_opt_check:n #1
  {
    \tl_if_in:nnTF {#1} { ] }
      { \@@_put_opt_arg_end:w #1 \s_@@ }
      {
        \tl_put_right:Nn \l_@@_stored_tl {#1}
        \@@_scan_provides_opt:
      }
  }
\cs_new_protected:Npn \@@_empty_provides_opt:
  { \use:x { \@@_put_opt_arg_end:w [ \c_novalue_tl ] \s_@@ } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_put_opt_arg_end:w}
%   When a |]| is found, add everything up to it to the storage token
%   list and compare it with the target token list saved earler.
%   If they are the same, return true, otherwise false.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_put_opt_arg_end:w #1 ] #2 \s_@@
  {
    \tl_put_right:Nn \l_@@_stored_tl { #1] }
    \str_if_eq:NNTF \l_@@_target_tl \l_@@_stored_tl
      { \bool_set_true:N \l_@@_needs_bool }
      { \bool_set_false:N \l_@@_needs_bool }
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\ExplSyntaxOff
%<@@=>
%    \end{macrocode}
%
% \subsection{The \pkg{filehook} package first aid}
%     
%    The \pkg{filehook} package implements hooks into file loading
%    commands. These days this is already provided by the kernel
%    albeit not with the same user interface. Until that package gets
%    updated (to use the kernel interfaces) we provide a
%    substitution. This does not offer all hooks from \pkg{filehook}
%    but all that have been used in packages available in \TeX{} Live.
%
%    Note that this doesn't fix \pkg{currfile} because that package
%    uses \pkg{filehook} but relies on the internals of the old
%    implementation.
%
%    \begin{macrocode}
\declare@file@substitution{filehook.sty}{filehook-ltx.sty}
%    \end{macrocode}
%
%    If a new filehook package becomes available it can be tested
%    simply by  undoing the above substitution via
%    \begin{verbatim}
%  \undeclare@file@substitution{filehook.sty}
%    \end{verbatim}
%    Once ready this will then taken out of the first aid file.
%    
%    \begin{macrocode}
%</kernel>
%    \end{macrocode}
%
%    What follows is a partial implementation of the  \pkg{filehook}
%    interfaces.
%
%    Not implemented are:
%\begin{verbatim}
%  \AtBeginOfFiles
%  \AtEndOfFiles
%  \AtBeginOfInputs
%  \AtEndOfInputs
%  \AtBeginOfInputFile
%  \AtEndOfInputFile
%\end{verbatim}
%
%    \begin{macrocode}
%<*filehook>
%    \end{macrocode}
%
%    \begin{macrocode}
\newcommand\AtBeginOfEveryFile [1]
  {\AddToHook{file/before}{#1}}
\newcommand\AtEndOfEveryFile [1]
  {\AddToHook{file/after}{#1}}
%    \end{macrocode}
%    
%    \begin{macrocode}
\newcommand\AtBeginOfIncludes [1]
  {\AddToHook{include/before}{#1}}
\newcommand\AtEndOfIncludes [1]
  {\AddToHook{include/end}{#1}}
\newcommand\AfterIncludes [1]
  {\AddToHook{include/after}{#1}}
%    \end{macrocode}
%    
%    \begin{macrocode}
\newcommand\AtBeginOfPackages [1]
  {\AddToHook{package/before}{#1}}
\newcommand\AtEndOfPackages [1]
  {\AddToHook{package/after}{#1}}
%    \end{macrocode}
%    
%    \begin{macrocode}
\newcommand\AtBeginOfClasses [1]
  {\AddToHook{class/before}{#1}}
\newcommand\AtEndOfClasses [1]
  {\AddToHook{class/after}{#1}}
%    \end{macrocode}
%
%    For normal files we drop the \texttt{.tex} extension for now:
%    \begin{macrocode}
\newcommand\AtBeginOfFile [2]
  {\AddToHook{file/before/#1}{#2}}
\newcommand\AtEndOfFile [2]
  {\AddToHook{file/after/#1}{#2}}
%    \end{macrocode}
%    
%    \begin{macrocode}
\DeclareDocumentCommand \AtBeginOfPackageFile {smm}
   {\IfBooleanTF{#1}%
     {\@ifpackageloaded{#2}%
         {#3}%
         {\AddToHook{package/before/#2}{#3}}}%
     {\AddToHook{package/before/#2}{#3}}%
   }
\DeclareDocumentCommand \AtEndOfPackageFile {smm}
   {\IfBooleanTF{#1}%
     {\@ifpackageloaded{#2}%
         {#3}%
         {\AddToHook{package/after/#2}{#3}}}%
     {\AddToHook{package/after/#2}{#3}}%
   }
%    \end{macrocode}
%
%    Are the * forms here of any use? I know they are use 3--4 times
%    on CTAN but I wonder if those are real or mistaken usages.  
%    \begin{macrocode}
\DeclareDocumentCommand \AtBeginOfClassFile {smm}
   {\IfBooleanTF{#1}%
     {\@ifclassloaded{#2}%
         {#3}%
         {\AddToHook{class/before/#2}{#3}}}%
     {\AddToHook{class/before/#2}{#3}}%
   }
\DeclareDocumentCommand \AtEndOfClassFile {smm}
   {\IfBooleanTF{#1}%
     {\@ifclassloaded{#2}%
         {#3}%
         {\AddToHook{class/after/#2}{#3}}}%
     {\AddToHook{class/after/#2}{#3}}%
   }
%    \end{macrocode}
%    
%    \begin{macrocode}
\newcommand\AtBeginOfIncludeFile [2]
  {\AddToHook{include/before/#1}{#2}}
\newcommand\AtEndOfIncludeFile [2]
  {\AddToHook{include/end/#1}{#2}}
\newcommand\AfterIncludeFile [2]
  {\AddToHook{include/after/#1}{#2}}
%    \end{macrocode}
%
%
%    This is missing some interfaces so disabling the package isn't
%    really correct, but then this code above is not supposed to stay
%    like this anyway.
%    \begin{macrocode}
\expandafter\let\csname ver@filehook.sty\endcsname\fmtversion
\@namedef {ver@filehook.sty}{2020/10/01}
%    \end{macrocode}
%
%
%    \begin{macrocode}
%</filehook>
%    \end{macrocode}
%
%
%
% \subsection{The \pkg{bidi} package first aid}
%
%     The \pkg{bidi} package adds a lot of hooks in various places and
%    those added to \cs{document} and \cs{enddocument} are now no
%    longer necessary as the kernel already provides the right hooks
%    there.
%
%    However, we aren't trying to change that but instead only make
%    sure that the existing patches still work by adding some first
%    aid after \pkg{biditools} has been loaded.
%
%    If the package gets updated one can easily take that out simply
%    through
%\begin{verbatim}
%  \RemoveFromHook{file/after/biditools.sty}[firstaid]
%\end{verbatim}
%    This makes it easy to test new bidi code while the first aid code
%    is still in the kernel.
%
%    \begin{macrocode}
\AddToHook{file/after/biditools.sty}[firstaid]{%
%    \end{macrocode}
%    \pkg{bidi} adds some code to the beginning of \cs{document} which
%    contains \cs{endgroup} and \cs{begingroup} which is no longer
%    correct.
%  
%    Patching \cs{document} using \cs{bidi@patchcmd} doesn't work so
%    we take the extra groups out by hand:
%    \begin{macrocode}
  \def\firstaid@bidi@document@patch
          \endgroup#1\begingroup#2\firstaid@bidi@document@patch
          {\unexpanded{#1#2}}%
  \edef\document{\expandafter\firstaid@bidi@document@patch\document
            \firstaid@bidi@document@patch}%
%    \end{macrocode}
%    There are also some patches into \cs{enddocument}, some continue
%    to go in but one fails, so we add that now into the right place.
%    \begin{macrocode}
  \AddToHook{enddocument/info}%
            {\let\bidi@AfterEndDocumentCheckLabelsRerun\@firstofone
              \bidi@afterenddocumentchecklabelsrerunhook}%
}
%    \end{macrocode}
%    
%    \begin{macrocode}
%<*kernel>
%    \end{macrocode}
%
%
%
% \subsection{The \pkg{dinbrief} class first aid}
%
%    Again a case of a no longer correct \cs{endgroup} in document.
%    Here the fix is simply though.
%    \begin{macrocode}
\AddToHook{file/after/dinbrief.cls}[firstaid]{%
  \AddToHook{env/document/begin}{\begingroup}%
}
%    \end{macrocode}
%
%
%
%
%
%    \begin{macrocode}
%</kernel>
%    \end{macrocode}
%
% \Finale
%
